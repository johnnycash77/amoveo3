(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (Buffer){

const path = require('path')
const extension = require('extensionizer')

const inpageContent = Buffer("KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9ImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoIkNhbm5vdCBmaW5kIG1vZHVsZSAnIitpKyInIik7dGhyb3cgYS5jb2RlPSJNT0RVTEVfTk9UX0ZPVU5EIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9ImZ1bmN0aW9uIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKY29uc3QgaXNUZXN0bmV0ID0gZmFsc2U7Cgpjb25zdCB0ZXN0bmV0Q2hlY2twb2ludCA9IFsiaGVhZGVyIiwgNTAsImF2bVRDdmhXNjJJNWIxWktXL2sraE41VmtEVFJCVWZOT01MMUliRGVCRU09IiwiSHRDVyt4ZWpFcitoVng5RVUvWVdxamtUb0hmQjY1THpuWC83a1lZMXFZYz0iLCIvbmt5MjlnZmZMNTE5ZklTaHhZdGxHWXJTbC9WdllZU3cwUWsyRi8rUTRrPSIsMjgzMjk3MzQ3LDQ4NjEsMCwiQUFBQUFBQUFBQUFBb0FDNTFIWWVxRCtSanlIMUV3MXRkZWJWVDMvQkQ2Zz0iLDEwMDYyMzkwNzIsNzQ2XQpjb25zdCBtYWlubmV0Q2hlY2twb2ludCA9IFsiaGVhZGVyIiwgMzg2NzEsICJDb3l4ZGZqbFV6ZC9jdWpKUlMxaVRrc21FNWw3QzNsc3luKzJGWTBreG1VPSIsICIrQ3dUNFpHdllFMTBpNVRkb2NqMWorb2pTTm93RURwK0pxK3V3M3pkTzIwPSIsICJNck41anQ5djBYOTFLaXgzSEluRFAyNWROclRYT3QrdXgzZDJ5WTY0UU1rPSIsIDIxMjE2MzA3OSwgMTM2OTgsIDMsICJBQUFBQUFBQUFBQUFodjg2ZGdBQUFBQVY3OXRpQUFBQUFBQVd4d0FBWmpjPSIsIDQwMjQzMjYzOTE0MzA0MjM1MDAwMCwgNTk4Ml0KCmNvbnN0IGNvbmZpZyA9IHsKICAgIGlzVGVzdG5ldDogaXNUZXN0bmV0LAogICAgZGVmYXVsdEZlZTogMC4wMDE1MTE2OCwKICAgIGRlY2ltYWxNdWx0aXBsaWVyOiAxMDAwMDAwMDAsCiAgICBkZWZhdWx0Tm9kZVVybDogaXNUZXN0bmV0ID8gJ2h0dHA6Ly8xMjcuMC4wLjEnIDogJ2h0dHA6Ly80MC4xMTcuMTk2LjU1JywKICAgIGRlZmF1bHROb2RlUG9ydDogaXNUZXN0bmV0ID8gJzgwNzAnIDogJzgwODAnLAogICAgY29uZmlnU3RyZWFtTmFtZTogJ3B1YmxpY0NvbmZpZ1N0b3JlJywKICAgIGNoYW5uZWxTdHJlYW1OYW1lOiAnQ2hhbm5lbFN0b3JlJywKICAgIHJldGFyZ2V0RnJlcXVlbmN5OiBpc1Rlc3RuZXQgPyAxMiA6IDIwMDAsCiAgICBmb3JrczogaXNUZXN0bmV0ID8ge3R3bzogMCwgZm91cjogMTIsIHNldmVuOjQwfSA6IHt0d286IDkwMDAsIGZvdXI6IDI2OTAwLCBzZXZlbjoyODEzNX0sCiAgICBjaGVja1BvaW50SGVhZGVyOiBpc1Rlc3RuZXQgPyB0ZXN0bmV0Q2hlY2twb2ludCA6IG1haW5uZXRDaGVja3BvaW50LAogICAgY2hlY2tQb2ludEV3YWg6IGlzVGVzdG5ldCA/IDcxMzEwNDogMjE3NzczMjE4NzgwNjcwNywKICAgIGluaXRpYWxEaWZmaWN1bHR5OiBpc1Rlc3RuZXQgPyAyNTAwIDogODg0NCwKICAgIGhlYWRlcnNCYXRjaDogNTAwMCwKICAgIGFwcFRpdGxlOiAiQW1vdmVvMyBXYWxsZXQiLAp9Cgptb2R1bGUuZXhwb3J0cyA9IGNvbmZpZzsKCn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKZ2xvYmFsID0gd2luZG93OwoKCmNsZWFuQ29udGV4dEZvckltcG9ydHMoKQoKY29uc3QgQW1vdmVvMyA9IHJlcXVpcmUoJy4vbGliL2Ftb3ZlbzMvYW1vdmVvMy5qcycpCmNvbnN0IGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykKY29uc3QgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtID0gcmVxdWlyZSgncG9zdC1tZXNzYWdlLXN0cmVhbScpCmNvbnN0IHNldHVwRGFwcEF1dG9SZWxvYWQgPSByZXF1aXJlKCcuL2xpYi9hdXRvcmVsb2FkLmpzJykKY29uc3QgQW1vdmVvSW5wYWdlUHJvdmlkZXIgPSByZXF1aXJlKCcuL2xpYi9pbnBhZ2UtcHJvdmlkZXIuanMnKQpyZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpCgpsb2cuc2V0RGVmYXVsdExldmVsKHByb2Nlc3MuZW52LkFNT1ZFT19ERUJVRyA/ICdkZWJ1ZycgOiAnd2FybicpCgovLwovLyBzZXR1cCBwbHVnaW4gY29tbXVuaWNhdGlvbgovLwoKLy8gc2V0dXAgYmFja2dyb3VuZCBjb25uZWN0aW9uCnZhciBiYWNrZ3JvdW5kU3RyZWFtID0gbmV3IExvY2FsTWVzc2FnZUR1cGxleFN0cmVhbSh7CiAgbmFtZTogJ2lucGFnZV9idW5kbGUnLAogIHRhcmdldDogJ2NzX2J1bmRsZScsCn0pCgovLyBjb21wb3NlIHRoZSBpbnBhZ2UgcHJvdmlkZXIKdmFyIGlucGFnZVByb3ZpZGVyID0gbmV3IEFtb3Zlb0lucGFnZVByb3ZpZGVyKGJhY2tncm91bmRTdHJlYW0pCgovLwovLyBzZXR1cCBhbW92ZW8zCi8vCgppZiAodHlwZW9mIHdpbmRvdy5hbW92ZW8zICE9PSAndW5kZWZpbmVkJykgewogIHRocm93IG5ldyBFcnJvcihgQW1vdmVvIGRldGVjdGVkIGFub3RoZXIgYW1vdmVvMy4KICAgICBBbW92ZW8gd2lsbCBub3Qgd29yayByZWxpYWJseSB3aXRoIGFub3RoZXIgd2ViMyBleHRlbnNpb24uCiAgICAgVGhpcyB1c3VhbGx5IGhhcHBlbnMgaWYgeW91IGhhdmUgdHdvIEFtb3Zlb3MgaW5zdGFsbGVkLAogICAgIG9yIEFtb3ZlbyBhbmQgYW5vdGhlciBhbW92ZW8zIGV4dGVuc2lvbi4gUGxlYXNlIHJlbW92ZSBvbmUKICAgICBhbmQgdHJ5IGFnYWluLmApCn0KdmFyIGFtb3ZlbzMgPSBuZXcgQW1vdmVvMyhpbnBhZ2VQcm92aWRlcikKYW1vdmVvMy5zZXRQcm92aWRlciA9IGZ1bmN0aW9uICgpIHsKICBsb2cuZGVidWcoJ0Ftb3ZlbyBXYWxsZXQgLSBvdmVycm9kZSBhbW92ZW8zLnNldFByb3ZpZGVyJykKfQpsb2cuZGVidWcoJ0Ftb3ZlbyBXYWxsZXQgLSBpbmplY3RlZCBhbW92ZW8zJykKLy8gZXhwb3J0IGdsb2JhbCB3ZWIzLCB3aXRoIHVzYWdlLWRldGVjdGlvbgoKc2V0dXBEYXBwQXV0b1JlbG9hZChhbW92ZW8zLCBpbnBhZ2VQcm92aWRlci5wb3J0KTsKCi8vIHNldCB3ZWIzIGRlZmF1bHRBY2NvdW50CmlucGFnZVByb3ZpZGVyLnN1YnNjcmliZShmdW5jdGlvbihyZXF1ZXN0KSB7CiAgaWYgKHJlcXVlc3QudHlwZSA9PT0gInNldFN0YXRlIikgewoJICBjb25zdCBzdGF0ZSA9IHJlcXVlc3QuZGF0YTsKCSAgYW1vdmVvMy5zZXRDb2luYmFzZShzdGF0ZS5zZWxlY3RlZEFkZHJlc3MpOwoJICBhbW92ZW8zLnNldENoYW5uZWxzKHN0YXRlLmNoYW5uZWxzKTsKCSAgYW1vdmVvMy5zZXRMb2NrZWQoc3RhdGUuaXNMb2NrZWQpOwogIH0KfSkKCi8vaW5wYWdlUHJvdmlkZXIuY2hhbm5lbHNTdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0YXRlKSB7Ci8vICBhbW92ZW8zLnNldENoYW5uZWxzKHN0YXRlLmNoYW5uZWxzKTsKLy99KQoKLy8gbmVlZCB0byBtYWtlIHN1cmUgd2UgYXJlbid0IGFmZmVjdGVkIGJ5IG92ZXJsYXBwaW5nIG5hbWVzcGFjZXMKLy8gYW5kIHRoYXQgd2UgZG9udCBhZmZlY3QgdGhlIGFwcCB3aXRoIG91ciBuYW1lc3BhY2UKLy8gbW9zdGx5IGEgZml4IGZvciB3ZWIzJ3MgQmlnTnVtYmVyIGlmIEFNRCdzICJkZWZpbmUiIGlzIGRlZmluZWQuLi4KdmFyIF9fZGVmaW5lCgovKioKICogQ2FjaGVzIHJlZmVyZW5jZSB0byBnbG9iYWwgZGVmaW5lIG9iamVjdCBhbmQgZGVsZXRlcyBpdCB0bwogKiBhdm9pZCBjb25mbGljdHMgd2l0aCBvdGhlciBnbG9iYWwgZGVmaW5lIG9iamVjdHMsIHN1Y2ggYXMKICogQU1EJ3MgZGVmaW5lIGZ1bmN0aW9uCiAqLwpmdW5jdGlvbiBjbGVhbkNvbnRleHRGb3JJbXBvcnRzICgpIHsKICBfX2RlZmluZSA9IGdsb2JhbC5kZWZpbmUKICB0cnkgewogICAgZ2xvYmFsLmRlZmluZSA9IHVuZGVmaW5lZAogIH0gY2F0Y2ggKF8pIHsKICAgIGNvbnNvbGUud2FybignQW1vdmVvIFdhbGxldCAtIGdsb2JhbC5kZWZpbmUgY291bGQgbm90IGJlIGRlbGV0ZWQuJykKICB9Cn0KCi8qKgogKiBSZXN0b3JlcyBnbG9iYWwgZGVmaW5lIG9iamVjdCBmcm9tIGNhY2hlZCByZWZlcmVuY2UKICovCmZ1bmN0aW9uIHJlc3RvcmVDb250ZXh0QWZ0ZXJJbXBvcnRzICgpIHsKICB0cnkgewogICAgZ2xvYmFsLmRlZmluZSA9IF9fZGVmaW5lCiAgfSBjYXRjaCAoXykgewogICAgY29uc29sZS53YXJuKCdBbW92ZW8gV2FsbGV0IC0gZ2xvYmFsLmRlZmluZSBjb3VsZCBub3QgYmUgb3ZlcndyaXR0ZW4uJykKICB9Cn0KfSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vbGliL2Ftb3ZlbzMvYW1vdmVvMy5qcyI6MywiLi9saWIvYXV0b3JlbG9hZC5qcyI6NSwiLi9saWIvaW5wYWdlLXByb3ZpZGVyLmpzIjo2LCJfcHJvY2VzcyI6MzIsImxvZ2xldmVsIjoxMCwicG9zdC1tZXNzYWdlLXN0cmVhbSI6MTF9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKdmFyIEFwaSA9IHJlcXVpcmUoJy4vYXBpJyk7CgpmdW5jdGlvbiBBbW92ZW8zKHByb3ZpZGVyKSB7CiAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyOwogICAgdGhpcy5hcGkgPSBuZXcgQXBpKCk7CiAgICB0aGlzLmNoYW5uZWxzID0gW107Cn0KCkFtb3ZlbzMucHJvdG90eXBlLnNldFByb3ZpZGVyID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7CiAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyOwp9OwoKQW1vdmVvMy5wcm90b3R5cGUuc2V0Q29pbmJhc2UgPSBmdW5jdGlvbiAoY29pbmJhc2UpIHsKICAgIHRoaXMuY29pbmJhc2UgPSBjb2luYmFzZTsKfTsKCkFtb3ZlbzMucHJvdG90eXBlLnNldENoYW5uZWxzID0gZnVuY3Rpb24gKGNoYW5uZWxzKSB7CiAgICB0aGlzLmNoYW5uZWxzID0gY2hhbm5lbHM7Cn07CgpBbW92ZW8zLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuICh0aGlzLmN1cnJlbnRQcm92aWRlcik7Cn07CgpBbW92ZW8zLnByb3RvdHlwZS5zZXRMb2NrZWQgPSBmdW5jdGlvbiAobG9ja2VkKSB7CiAgICB0aGlzLmlzTG9ja2VkID0gbG9ja2VkOwp9OwoKQW1vdmVvMy5wcm90b3R5cGUuaXNMb2NrZWQgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiB0aGlzLmlzTG9ja2VkOwp9OwoKQW1vdmVvMy5wcm90b3R5cGUuZ2V0VG9wSGVhZGVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHsKICAgIHRoaXMuYXBpLmdldEhlYWRlcnMoZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlKSB7CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSk7CiAgICB9KTsKfTsKCm1vZHVsZS5leHBvcnRzID0gQW1vdmVvMzsKfSx7Ii4vYXBpIjo0fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vLi4vLi4vY29uZmlnJyk7CgpmdW5jdGlvbiBBcGkoaG9zdCwgdGltZW91dCwgaGVhZGVycykgewogICAgdGhpcy5ob3N0ID0gaG9zdCB8fCAnaHR0cDovLzE1OS42NS4xMjAuODQ6ODA4MCc7CiAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0IHx8IDE7CiAgICB0aGlzLm5ldHdvcmsgPSBjb25maWcuaXNUZXN0bmV0ID8gInRlc3RuZXQiIDogIm1haW5uZXQiOwogICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyB8fCB7fTsKfQoKQXBpLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24gZ2V0SGVhZGVycyhjYWxsYmFjaykgewogICAgdmFyIGhlYWRlciA9IDA7CiAgICByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCBoZWFkZXIpOwp9Cgptb2R1bGUuZXhwb3J0cyA9IEFwaTsKfSx7Ii4vLi4vLi4vY29uZmlnIjoxfV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKbW9kdWxlLmV4cG9ydHMgPSBzZXR1cERhcHBBdXRvUmVsb2FkCgpmdW5jdGlvbiBzZXR1cERhcHBBdXRvUmVsb2FkIChhbW92ZW8zLCBwb3J0KSB7CiAgbGV0IHJlbG9hZEluUHJvZ3Jlc3MgPSBmYWxzZQogIGxldCBsYXN0VGltZVVzZWQKICBsZXQgbGFzdFNlZW5OZXR3b3JrOwogIGxldCBsYXN0U2VlbkFjY291bnQ7CiAgbGV0IGxhc3RTZWVuTG9ja2VkOwoKICBnbG9iYWwuYW1vdmVvMyA9IG5ldyBQcm94eShhbW92ZW8zLCB7CiAgICBnZXQ6IChfYW1vdmVvMywga2V5KSA9PiB7CiAgICAgIGxhc3RUaW1lVXNlZCA9IERhdGUubm93KCkKICAgICAgcmV0dXJuIF9hbW92ZW8zW2tleV0KICAgIH0sCiAgICBzZXQ6IChfYW1vdmVvMywga2V5LCB2YWx1ZSkgPT4gewogICAgICBfYW1vdmVvM1trZXldID0gdmFsdWUKICAgIH0sCiAgfSkKCiAgcG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24ocmVxdWVzdCkgewogICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gInNldFN0YXRlIikgewogICAgICAgIGNvbnN0IHN0YXRlID0gcmVxdWVzdC5kYXRhOwoKCSAgICBpZiAocmVsb2FkSW5Qcm9ncmVzcykgewoJCSAgICByZXR1cm4KCSAgICB9CgoJICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrID0gc3RhdGUubmV0d29yawoJICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50ID0gc3RhdGUuc2VsZWN0ZWRBZGRyZXNzCgkgICAgY29uc3QgaXNMb2NrZWQgPSBzdGF0ZS5pc0xvY2tlZAoKCSAgICBpZiAoIWxhc3RTZWVuTmV0d29yaykgewoJCSAgICBsYXN0U2Vlbk5ldHdvcmsgPSBjdXJyZW50TmV0d29yazsKCSAgICB9CgkgICAgaWYgKCFsYXN0U2VlbkFjY291bnQpIHsKCQkgICAgbGFzdFNlZW5BY2NvdW50ID0gY3VycmVudEFjY291bnQ7CgkgICAgfQoJICAgIGlmICghbGFzdFNlZW5Mb2NrZWQpIHsKCQkgICAgbGFzdFNlZW5Mb2NrZWQgPSBpc0xvY2tlZDsKCSAgICB9CgoJICAgIGNvbnN0IHNob3VsZFJlbG9hZCA9IGxhc3RTZWVuTmV0d29yayAhPT0gY3VycmVudE5ldHdvcmsgfHwgbGFzdFNlZW5BY2NvdW50ICE9PSBjdXJyZW50QWNjb3VudCB8fCBsYXN0U2VlbkxvY2tlZCAhPT0gaXNMb2NrZWQ7CgoJICAgIGxhc3RTZWVuTmV0d29yayA9IGN1cnJlbnROZXR3b3JrOwoJICAgIGxhc3RTZWVuQWNjb3VudCA9IGN1cnJlbnRBY2NvdW50OwoJICAgIGxhc3RTZWVuTG9ja2VkID0gaXNMb2NrZWQ7CgoJICAgIGlmIChzaG91bGRSZWxvYWQpIHsKCQkgICAgcmVsb2FkSW5Qcm9ncmVzcyA9IHRydWUKCQkgICAgY29uc3QgdGltZVNpbmNlVXNlID0gRGF0ZS5ub3coKSAtIGxhc3RUaW1lVXNlZAoJCSAgICAvLyBpZiBhbW92ZW8zIHdhcyByZWNlbnRseSB1c2VkIHRoZW4gZGVsYXkgdGhlIHJlbG9hZGluZyBvZiB0aGUgcGFnZQoJCSAgICBpZiAodGltZVNpbmNlVXNlID4gNTAwKSB7CgkJCSAgICB0cmlnZ2VyUmVzZXQoKQoJCSAgICB9IGVsc2UgewoJCQkgICAgc2V0VGltZW91dCh0cmlnZ2VyUmVzZXQsIDUwMCkKCQkgICAgfQoJICAgIH0KICAgIH0KICB9KQp9CgpmdW5jdGlvbiB0cmlnZ2VyUmVzZXQgKCkgewogIGdsb2JhbC5sb2NhdGlvbi5yZWxvYWQoKQp9Cn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBBbW92ZW9JbnBhZ2VQcm92aWRlcjsKCmNvbnN0IGV4dElkID0gImhmb2psZmZsbmxtZmpoZGRnb2RwbW9waG1ocGltYWhpIjsKCmZ1bmN0aW9uIEFtb3Zlb0lucGFnZVByb3ZpZGVyKGNvbm5lY3Rpb25TdHJlYW0pIHsKICAgIHRoaXMucG9ydCA9IGNocm9tZS5ydW50aW1lLmNvbm5lY3QoZXh0SWQpOwp9CgpBbW92ZW9JbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHsKCWlmIChjYWxsYmFjaykgewoJCXRoaXMucG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKGRhdGEpIHsKCQkJY2FsbGJhY2soZGF0YSk7CgkJfSk7Cgl9Cn0KCkFtb3Zlb0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7Cgljb25zdCBwb3J0ID0gdGhpcy5wb3J0OwoJcG9ydC5wb3N0TWVzc2FnZShvcHRzKTsKCWlmIChjYWxsYmFjaykgewoJCWZ1bmN0aW9uIHNlbmRMaXN0ZW5lcihkYXRhKSB7CgkJCWlmIChkYXRhLnR5cGUgPT09IG9wdHMudHlwZSkgewoJCQkJaWYgKGRhdGEuZXJyb3IpIHsKCQkJCQljYWxsYmFjayhkYXRhLmVycm9yLCBudWxsKTsKCQkJCX0gZWxzZSB7CgkJCQkJY2FsbGJhY2sobnVsbCwgZGF0YSk7CgkJCQl9CgkJCQlwb3J0Lm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihzZW5kTGlzdGVuZXIpOwoJCQl9CgkJfQoJCXBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKHNlbmRMaXN0ZW5lcik7Cgl9Cn0KCkFtb3Zlb0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gKG9wdHMsIGNhbGxiYWNrKSB7Cgljb25zdCBwb3J0ID0gdGhpcy5wb3J0OwoJcG9ydC5wb3N0TWVzc2FnZShvcHRzKTsKCWlmIChjYWxsYmFjaykgewoJCWZ1bmN0aW9uIHNpZ25MaXN0ZW5lcihkYXRhKSB7CgkJCWlmIChkYXRhLnR5cGUgPT09ICJzaWduIikgewoJCQkJaWYgKGRhdGEuZXJyb3IpIHsKCQkJCQljYWxsYmFjayhkYXRhLmVycm9yLCBudWxsKTsKCQkJCX0gZWxzZSB7CgkJCQkJY2FsbGJhY2sobnVsbCwgZGF0YS5zaWduZWQucyk7CgkJCQl9CgkJCQlwb3J0Lm9uTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihzaWduTGlzdGVuZXIpOwoJCQl9CgkJfQoJCXBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKHNpZ25MaXN0ZW5lcik7Cgl9Cn0KCkFtb3Zlb0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHsKICByZXR1cm4gdHJ1ZQp9CgpBbW92ZW9JbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuaXNBbW92ZW8zV2FsbGV0ID0gZnVuY3Rpb24gKCkgewogICAgcmV0dXJuIHRydWUKfQoKfSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoQnVmZmVyKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgCi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLgoKZnVuY3Rpb24gaXNBcnJheShhcmcpIHsKICBpZiAoQXJyYXkuaXNBcnJheSkgewogICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTsKICB9CiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7Cn0KZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTsKCmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nOwp9CmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuOwoKZnVuY3Rpb24gaXNOdWxsKGFyZykgewogIHJldHVybiBhcmcgPT09IG51bGw7Cn0KZXhwb3J0cy5pc051bGwgPSBpc051bGw7CgpmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09IG51bGw7Cn0KZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOwp9CmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjsKCmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJzsKfQpleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7CgpmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7Cn0KZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sOwoKZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwOwp9CmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7CiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7Cn0KZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwOwoKZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDsKfQpleHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7CgpmdW5jdGlvbiBpc0RhdGUoZCkgewogIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nOwp9CmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlOwoKZnVuY3Rpb24gaXNFcnJvcihlKSB7CiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpOwp9CmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7CgpmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwp9CmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247CgpmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbAogICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJzsKfQpleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7CgpleHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyOwoKZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykgewogIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7Cn0KCn0pLmNhbGwodGhpcyx7ImlzQnVmZmVyIjpyZXF1aXJlKCIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiKX0pCn0seyIuLi8uLi8uLi8uLi8uLi8uLi91c3IvbG9jYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiOjMxfV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7CmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykgewogIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlCiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHsKICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yCiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwgewogICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgIHZhbHVlOiBjdG9yLAogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICB9CiAgICB9KTsKICB9Owp9IGVsc2UgewogIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzCiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHsKICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yCiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fQogICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZQogICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKQogICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yCiAgfQp9Cgp9LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7Cgptb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikgewogIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJzsKfTsKCn0se31dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKLyoKKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbAoqCiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeQoqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4KKi8KKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7CiAgICAidXNlIHN0cmljdCI7CiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7CiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pOwogICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgewogICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpOwogICAgfSBlbHNlIHsKICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTsKICAgIH0KfSh0aGlzLCBmdW5jdGlvbiAoKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZQogICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9OwogICAgdmFyIHVuZGVmaW5lZFR5cGUgPSAidW5kZWZpbmVkIjsKCiAgICB2YXIgbG9nTWV0aG9kcyA9IFsKICAgICAgICAidHJhY2UiLAogICAgICAgICJkZWJ1ZyIsCiAgICAgICAgImluZm8iLAogICAgICAgICJ3YXJuIiwKICAgICAgICAiZXJyb3IiCiAgICBdOwoKICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTYKICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7CiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTsKICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmcKICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudgogICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzCiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHsKICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykgewogICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzCiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7CiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbm9vcDsKICAgICAgICB9CiAgICB9CgogICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseQoKICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkgewogICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTsKICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID8KICAgICAgICAgICAgICAgIG5vb3AgOgogICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTsKICAgICAgICB9CgogICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWcKICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7CiAgICB9CgogICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LgogICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHMKICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHsKICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTsKICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgIH07CiAgICB9CgogICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmQKICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uCiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkgewogICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovCiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHwKICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfQoKICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHsKICAgICAgdmFyIHNlbGYgPSB0aGlzOwogICAgICB2YXIgY3VycmVudExldmVsOwogICAgICB2YXIgc3RvcmFnZUtleSA9ICJsb2dsZXZlbCI7CiAgICAgIGlmIChuYW1lKSB7CiAgICAgICAgc3RvcmFnZUtleSArPSAiOiIgKyBuYW1lOwogICAgICB9CgogICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7CiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpOwoKICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47CgogICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGUKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CgogICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrCiAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPQogICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgIj0iICsgbGV2ZWxOYW1lICsgIjsiOwogICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fQogICAgICB9CgogICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHsKICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDsKCiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuOwoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldOwogICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fQoKICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nCiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7CiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKAogICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgIj0iKTsKICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkgewogICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CiAgICAgICAgICB9CgogICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC4KICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDsKICAgICAgfQoKICAgICAgLyoKICAgICAgICoKICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzCiAgICAgICAqCiAgICAgICAqLwoKICAgICAgc2VsZi5uYW1lID0gbmFtZTsKCiAgICAgIHNlbGYubGV2ZWxzID0geyAiVFJBQ0UiOiAwLCAiREVCVUciOiAxLCAiSU5GTyI6IDIsICJXQVJOIjogMywKICAgICAgICAgICJFUlJPUiI6IDQsICJTSUxFTlQiOiA1fTsKCiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7CgogICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDsKICAgICAgfTsKCiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHsKICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICJzdHJpbmciICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gIm51bWJlciIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHsKICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDsKICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWUKICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZyI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aHJvdyAibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogIiArIGxldmVsOwogICAgICAgICAgfQogICAgICB9OwoKICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHsKICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkgewogICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTsKICAgICAgICAgIH0KICAgICAgfTsKCiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkgewogICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7CiAgICAgIH07CgogICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7CiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7CiAgICAgIH07CgogICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsCiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpOwogICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHsKICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gIldBUk4iIDogZGVmYXVsdExldmVsOwogICAgICB9CiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7CiAgICB9CgogICAgLyoKICAgICAqCiAgICAgKiBUb3AtbGV2ZWwgQVBJCiAgICAgKgogICAgICovCgogICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7CgogICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307CiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7CiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAic3RyaW5nIiB8fCBuYW1lID09PSAiIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLiIpOwogICAgICAgIH0KCiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdOwogICAgICAgIGlmICghbG9nZ2VyKSB7CiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoCiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxvZ2dlcjsKICAgIH07CgogICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlCiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7CiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJgogICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7CiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7CiAgICB9OwoKICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7CiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lOwogICAgfTsKCiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjsKfSkpOwoKfSx7fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewpjb25zdCBEdXBsZXhTdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5EdXBsZXgKY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMKCm1vZHVsZS5leHBvcnRzID0gUG9zdE1lc3NhZ2VTdHJlYW0KCmluaGVyaXRzKFBvc3RNZXNzYWdlU3RyZWFtLCBEdXBsZXhTdHJlYW0pCgpmdW5jdGlvbiBQb3N0TWVzc2FnZVN0cmVhbSAob3B0cykgewogIER1cGxleFN0cmVhbS5jYWxsKHRoaXMsIHsKICAgIG9iamVjdE1vZGU6IHRydWUsCiAgfSkKCiAgdGhpcy5fbmFtZSA9IG9wdHMubmFtZQogIHRoaXMuX3RhcmdldCA9IG9wdHMudGFyZ2V0CiAgdGhpcy5fdGFyZ2V0V2luZG93ID0gb3B0cy50YXJnZXRXaW5kb3cgfHwgd2luZG93CiAgdGhpcy5fb3JpZ2luID0gKG9wdHMudGFyZ2V0V2luZG93ID8gJyonIDogbG9jYXRpb24ub3JpZ2luKQoKICAvLyBpbml0aWFsaXphdGlvbiBmbGFncwogIHRoaXMuX2luaXQgPSBmYWxzZQogIHRoaXMuX2hhdmVTeW4gPSBmYWxzZQoKICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpLCBmYWxzZSkKICAvLyBzZW5kIHN5bmNvcml6YXRpb24gbWVzc2FnZQogIHRoaXMuX3dyaXRlKCdTWU4nLCBudWxsLCBub29wKQogIHRoaXMuY29yaygpCn0KCi8vIHByaXZhdGUKUG9zdE1lc3NhZ2VTdHJlYW0ucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsKICB2YXIgbXNnID0gZXZlbnQuZGF0YQoKICAvLyB2YWxpZGF0ZSBtZXNzYWdlCiAgaWYgKHRoaXMuX29yaWdpbiAhPT0gJyonICYmIGV2ZW50Lm9yaWdpbiAhPT0gdGhpcy5fb3JpZ2luKSByZXR1cm4KICBpZiAoZXZlbnQuc291cmNlICE9PSB0aGlzLl90YXJnZXRXaW5kb3cpIHJldHVybgogIGlmICh0eXBlb2YgbXNnICE9PSAnb2JqZWN0JykgcmV0dXJuCiAgaWYgKG1zZy50YXJnZXQgIT09IHRoaXMuX25hbWUpIHJldHVybgogIGlmICghbXNnLmRhdGEpIHJldHVybgoKICBpZiAoIXRoaXMuX2luaXQpIHsKICAgIGlmIChtc2cuZGF0YSA9PT0gJ1NZTicpIHsKICAgICAgdGhpcy5faGF2ZVN5biA9IHRydWUKICAgICAgdGhpcy5fd3JpdGUoJ0FDSycsIG51bGwsIG5vb3ApCiAgICB9IGVsc2UgaWYgKG1zZy5kYXRhID09PSAnQUNLJykgewogICAgICB0aGlzLl9pbml0ID0gdHJ1ZQogICAgICBpZiAoIXRoaXMuX2hhdmVTeW4pIHsKICAgICAgICB0aGlzLl93cml0ZSgnQUNLJywgbnVsbCwgbm9vcCkKICAgICAgfQogICAgICB0aGlzLnVuY29yaygpCiAgICB9CiAgfSBlbHNlIHsKICAgIC8vIGZvcndhcmQgbWVzc2FnZQogICAgdHJ5IHsKICAgICAgdGhpcy5wdXNoKG1zZy5kYXRhKQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpCiAgICB9CiAgfQp9CgovLyBzdHJlYW0gcGx1bWJpbmcKUG9zdE1lc3NhZ2VTdHJlYW0ucHJvdG90eXBlLl9yZWFkID0gbm9vcAoKUG9zdE1lc3NhZ2VTdHJlYW0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmNvZGluZywgY2IpIHsKICB2YXIgbWVzc2FnZSA9IHsKICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LAogICAgZGF0YTogZGF0YSwKICB9CiAgdGhpcy5fdGFyZ2V0V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRoaXMuX29yaWdpbikKICBjYigpCn0KCi8vIHV0aWwKCmZ1bmN0aW9uIG5vb3AgKCkge30KCn0seyJyZWFkYWJsZS1zdHJlYW0iOjIxLCJ1dGlsIjozNX1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzKXsKJ3VzZSBzdHJpY3QnOwoKaWYgKCFwcm9jZXNzLnZlcnNpb24gfHwKICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fAogICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7CiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9Owp9IGVsc2UgewogIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcwp9CgpmdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykgewogIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJjYWxsYmFjayIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CiAgfQogIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOwogIHZhciBhcmdzLCBpOwogIHN3aXRjaCAobGVuKSB7CiAgY2FzZSAwOgogIGNhc2UgMToKICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTsKICBjYXNlIDI6CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7CiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7CiAgICB9KTsKICBjYXNlIDM6CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7CiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7CiAgICB9KTsKICBjYXNlIDQ6CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHsKICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTsKICAgIH0pOwogIGRlZmF1bHQ6CiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpOwogICAgaSA9IDA7CiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7CiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTsKICAgIH0KICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHsKICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7CiAgICB9KTsKICB9Cn0KCgp9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkKfSx7Il9wcm9jZXNzIjozMn1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS4KLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3MKLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbQovLyBXcml0YWJsZS4KCid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHsKICB2YXIga2V5cyA9IFtdOwogIGZvciAodmFyIGtleSBpbiBvYmopIHsKICAgIGtleXMucHVzaChrZXkpOwogIH1yZXR1cm4ga2V5czsKfTsKLyo8L3JlcGxhY2VtZW50PiovCgptb2R1bGUuZXhwb3J0cyA9IER1cGxleDsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpOwp2YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTsKCnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7Cgp7CiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZAogIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpOwogIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykgewogICAgdmFyIG1ldGhvZCA9IGtleXNbdl07CiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07CiAgfQp9CgpmdW5jdGlvbiBEdXBsZXgob3B0aW9ucykgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTsKCiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTsKICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpOwoKICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlOwoKICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlOwoKICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlOwogIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlOwoKICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTsKfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7CiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGUKICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW4KICAvLyB1c2VybGFuZCB3aWxsIGZhaWwKICBlbnVtZXJhYmxlOiBmYWxzZSwKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7CiAgfQp9KTsKCi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXIKZnVuY3Rpb24gb25lbmQoKSB7CiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwKICAvLyB0aGVuIHdlJ3JlIG9rLgogIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOwoKICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uCiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suCiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpOwp9CgpmdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHsKICBzZWxmLmVuZCgpOwp9CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICB9LAogIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW0KICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQKICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5CiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogIH0KfSk7CgpEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHsKICB0aGlzLnB1c2gobnVsbCk7CiAgdGhpcy5lbmQoKTsKCiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpOwp9Owp9LHsiLi9fc3RyZWFtX3JlYWRhYmxlIjoxNSwiLi9fc3RyZWFtX3dyaXRhYmxlIjoxNywiY29yZS11dGlsLWlzIjo3LCJpbmhlcml0cyI6OCwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjEyfV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS4KLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uCi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuCgondXNlIHN0cmljdCc7Cgptb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoOwoKdmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7CgpmdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTsKCiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7Cn0KClBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBjYihudWxsLCBjaHVuayk7Cn07Cn0seyIuL19zdHJlYW1fdHJhbnNmb3JtIjoxNiwiY29yZS11dGlsLWlzIjo3LCJpbmhlcml0cyI6OH1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgptb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIER1cGxleDsKLyo8L3JlcGxhY2VtZW50PiovCgpSZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjsKCnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkgewogIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7Cn07Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwp2YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9OwpmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7CiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTsKfQpmdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikgewogIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5Owp9CgovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7CnZhciBkZWJ1ZyA9IHZvaWQgMDsKaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHsKICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7Cn0gZWxzZSB7CiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTsKfQovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTsKdmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTsKdmFyIFN0cmluZ0RlY29kZXI7Cgp1dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pOwoKdmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTsKCmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHsKICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93bgogIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLgogIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOwoKICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55CiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzCiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZQogIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay4KICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTsKfQoKZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOwoKICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmUKICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC4KICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudAogIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uCiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguCiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OwoKICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0bwogIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5CiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CgogIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7CgogIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyCiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyAiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlciIKICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrOwogIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrOwogIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7CgogIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtOwoKICAvLyBjYXN0IHRvIGludHMuCiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspOwoKICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZQogIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuCiAgLy8gYXJyYXkuc2hpZnQoKQogIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTsKICB0aGlzLmxlbmd0aCA9IDA7CiAgdGhpcy5waXBlcyA9IG51bGw7CiAgdGhpcy5waXBlc0NvdW50ID0gMDsKICB0aGlzLmZsb3dpbmcgPSBudWxsOwogIHRoaXMuZW5kZWQgPSBmYWxzZTsKICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTsKICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsKCiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZAogIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlCiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsICJsYXRlciIgc2hvdWxkIGdlbmVyYWxseSBhbHNvCiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC4KICB0aGlzLnN5bmMgPSB0cnVlOwoKICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheQogIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLgogIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7CiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7CiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKCiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkCiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsKCiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZwogIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS4KICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guCiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7CgogIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzCiAgdGhpcy5hd2FpdERyYWluID0gMDsKCiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZAogIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTsKCiAgdGhpcy5kZWNvZGVyID0gbnVsbDsKICB0aGlzLmVuY29kaW5nID0gbnVsbDsKICBpZiAob3B0aW9ucy5lbmNvZGluZykgewogICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjsKICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpOwogICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7CiAgfQp9CgpmdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7CiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsKCiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsKCiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpOwoKICAvLyBsZWdhY3kKICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTsKCiAgaWYgKG9wdGlvbnMpIHsKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkOwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95OwogIH0KCiAgU3RyZWFtLmNhbGwodGhpcyk7Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDsKICB9LAogIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW0KICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQKICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseQogICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkCiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogIH0KfSk7CgpSZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7ClJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwpSZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHRoaXMucHVzaChudWxsKTsKICBjYihlcnIpOwp9OwoKLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuCi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LAovLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkCi8vIHdyaXRlKCkgc29tZSBtb3JlLgpSZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBza2lwQ2h1bmtDaGVjazsKCiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7CiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykgewogICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZzsKICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykgewogICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTsKICAgICAgICBlbmNvZGluZyA9ICcnOwogICAgICB9CiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICAgIH0KICB9IGVsc2UgewogICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlOwogIH0KCiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spOwp9OwoKLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKCkKUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHsKICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpOwp9OwoKZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgaWYgKGNodW5rID09PSBudWxsKSB7CiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpOwogIH0gZWxzZSB7CiAgICB2YXIgZXI7CiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspOwogICAgaWYgKGVyKSB7CiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7CiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHsKICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspOwogICAgICB9CgogICAgICBpZiAoYWRkVG9Gcm9udCkgewogICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpOwogICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7CiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7CiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7CiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwogICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHsKICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgfQogIH0KCiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7Cn0KCmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7CiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7CiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTsKICAgIHN0cmVhbS5yZWFkKDApOwogIH0gZWxzZSB7CiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLgogICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKCiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTsKICB9CiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTsKfQoKZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykgewogIHZhciBlcjsKICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7CiAgfQogIHJldHVybiBlcjsKfQoKLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS4KLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUKLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsCi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhCi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdAovLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlcgovLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLgpmdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHsKICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApOwp9CgpSZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7Cn07CgovLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4KUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykgewogIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7CiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTsKICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jOwogIHJldHVybiB0aGlzOwp9OwoKLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQgp2YXIgTUFYX0hXTSA9IDB4ODAwMDAwOwpmdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7CiAgaWYgKG4gPj0gTUFYX0hXTSkgewogICAgbiA9IE1BWF9IV007CiAgfSBlbHNlIHsKICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpbgogICAgLy8gdGlueSBhbW91bnRzCiAgICBuLS07CiAgICBuIHw9IG4gPj4+IDE7CiAgICBuIHw9IG4gPj4+IDI7CiAgICBuIHw9IG4gPj4+IDQ7CiAgICBuIHw9IG4gPj4+IDg7CiAgICBuIHw9IG4gPj4+IDE2OwogICAgbisrOwogIH0KICByZXR1cm4gbjsKfQoKLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkgewogIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDsKICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7CiAgaWYgKG4gIT09IG4pIHsKICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZQogICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoOwogIH0KICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS4KICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTsKICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOwogIC8vIERvbid0IGhhdmUgZW5vdWdoCiAgaWYgKCFzdGF0ZS5lbmRlZCkgewogICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIHJldHVybiAwOwogIH0KICByZXR1cm4gc3RhdGUubGVuZ3RoOwp9CgovLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LgpSZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7CiAgZGVidWcoJ3JlYWQnLCBuKTsKICBuID0gcGFyc2VJbnQobiwgMTApOwogIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgdmFyIG5PcmlnID0gbjsKCiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwoKICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlCiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlcgogIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLgogIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7CiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7CiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTsKICAgIHJldHVybiBudWxsOwogIH0KCiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOwoKICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuCiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHsKICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpOwogICAgcmV0dXJuIG51bGw7CiAgfQoKICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlCiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluCiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZAogIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2UKICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlbgogIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLgogIC8vCiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6CiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkbwogIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuCiAgLy8KICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLgogIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpcwogIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhbgogIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmUKICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLgogIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbAogIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXQKICAvLyAncmVhZGFibGUnIGV0Yy4KICAvLwogIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi4KCiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLgogIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7CiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOwoKICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWUKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7CiAgICBkb1JlYWQgPSB0cnVlOwogICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTsKICB9CgogIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5CiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LgogIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7CiAgICBkb1JlYWQgPSBmYWxzZTsKICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTsKICB9IGVsc2UgaWYgKGRvUmVhZCkgewogICAgZGVidWcoJ2RvIHJlYWQnKTsKICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlOwogICAgc3RhdGUuc3luYyA9IHRydWU7CiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LgogICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2QKICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7CiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7CiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLAogICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLgogICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpOwogIH0KCiAgdmFyIHJldDsKICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7CgogIGlmIChyZXQgPT09IG51bGwpIHsKICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICBuID0gMDsKICB9IGVsc2UgewogICAgc3RhdGUubGVuZ3RoIC09IG47CiAgfQoKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3cKICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci4KICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CgogICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLgogICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTsKICB9CgogIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7CgogIHJldHVybiByZXQ7Cn07CgpmdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjsKICBpZiAoc3RhdGUuZGVjb2RlcikgewogICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTsKICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHsKICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspOwogICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CiAgICB9CiAgfQogIHN0YXRlLmVuZGVkID0gdHJ1ZTsKCiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuCiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7Cn0KCi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlcgovLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXIKLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLgpmdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlOwogIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7CiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7CiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlOwogICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pOwogIH0KfQoKZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHsKICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpOwogIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpOwogIGZsb3coc3RyZWFtKTsKfQoKLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCwKLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZAovLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZgovLyBpdCdzIGluIHByb2dyZXNzLgovLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLAovLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LgpmdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7CiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7CiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpOwogIH0KfQoKZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkgewogIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7CiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7CiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTsKICAgIHN0cmVhbS5yZWFkKDApOwogICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKQogICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLgogICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDsKICB9CiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTsKfQoKLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLgovLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLgovLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgImxlbmd0aCIgaXMgc29tZXdoYXQKLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLgpSZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikgewogIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpOwp9OwoKUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHsKICB2YXIgc3JjID0gdGhpczsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwoKICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHsKICAgIGNhc2UgMDoKICAgICAgc3RhdGUucGlwZXMgPSBkZXN0OwogICAgICBicmVhazsKICAgIGNhc2UgMToKICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdOwogICAgICBicmVhazsKICAgIGRlZmF1bHQ6CiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7CiAgICAgIGJyZWFrOwogIH0KICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7CiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTsKCiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjsKCiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTsKICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7CgogIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTsKICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykgewogICAgZGVidWcoJ29udW5waXBlJyk7CiAgICBpZiAocmVhZGFibGUgPT09IHNyYykgewogICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7CiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTsKICAgICAgICBjbGVhbnVwKCk7CiAgICAgIH0KICAgIH0KICB9CgogIGZ1bmN0aW9uIG9uZW5kKCkgewogICAgZGVidWcoJ29uZW5kJyk7CiAgICBkZXN0LmVuZCgpOwogIH0KCiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlcgogIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKQogIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzCiAgLy8gdG9vIHNsb3cuCiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpOwogIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7CgogIHZhciBjbGVhbmVkVXAgPSBmYWxzZTsKICBmdW5jdGlvbiBjbGVhbnVwKCkgewogICAgZGVidWcoJ2NsZWFudXAnKTsKICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW4KICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwogICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpOwogICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTsKCiAgICBjbGVhbmVkVXAgPSB0cnVlOwoKICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXMKICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydAogICAgLy8gZmxvd2luZyBhZ2Fpbi4KICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy4KICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS4KICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTsKICB9CgogIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwCiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2UKICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLgogIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi4KICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlOwogIHNyYy5vbignZGF0YScsIG9uZGF0YSk7CiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7CiAgICBkZWJ1Zygnb25kYXRhJyk7CiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7CiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7CiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikgewogICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGUKICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGUKICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS4KICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uCiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHsKICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pOwogICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7CiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7CiAgICAgIH0KICAgICAgc3JjLnBhdXNlKCk7CiAgICB9CiAgfQoKICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC4KICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuCiAgZnVuY3Rpb24gb25lcnJvcihlcikgewogICAgZGVidWcoJ29uZXJyb3InLCBlcik7CiAgICB1bnBpcGUoKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpOwogIH0KCiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLgogIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsKCiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS4KICBmdW5jdGlvbiBvbmNsb3NlKCkgewogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwogICAgdW5waXBlKCk7CiAgfQogIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTsKICBmdW5jdGlvbiBvbmZpbmlzaCgpIHsKICAgIGRlYnVnKCdvbmZpbmlzaCcpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKICAgIHVucGlwZSgpOwogIH0KICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCiAgZnVuY3Rpb24gdW5waXBlKCkgewogICAgZGVidWcoJ3VucGlwZScpOwogICAgc3JjLnVucGlwZShkZXN0KTsKICB9CgogIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvCiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsKCiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LgogIGlmICghc3RhdGUuZmxvd2luZykgewogICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7CiAgICBzcmMucmVzdW1lKCk7CiAgfQoKICByZXR1cm4gZGVzdDsKfTsKCmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykgewogIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7CiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTsKICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07CiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7CiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwogICAgICBmbG93KHNyYyk7CiAgICB9CiAgfTsKfQoKUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTsKCiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLgogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsKCiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLgogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7CiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS4KICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpczsKCiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsKCiAgICAvLyBnb3QgYSBtYXRjaC4KICAgIHN0YXRlLnBpcGVzID0gbnVsbDsKICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwOwogICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlOwogICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7CiAgICByZXR1cm4gdGhpczsKICB9CgogIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuCgogIGlmICghZGVzdCkgewogICAgLy8gcmVtb3ZlIGFsbC4KICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzOwogICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7CiAgICBzdGF0ZS5waXBlcyA9IG51bGw7CiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDsKICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7CiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwogICAgfXJldHVybiB0aGlzOwogIH0KCiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS4KICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTsKICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpczsKCiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTsKICBzdGF0ZS5waXBlc0NvdW50IC09IDE7CiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07CgogIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7CgogIHJldHVybiB0aGlzOwp9OwoKLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvcgovLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZwpSZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7CiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pOwoKICBpZiAoZXYgPT09ICdkYXRhJykgewogICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkCiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTsKICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7CiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykgewogICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOwogICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7CiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7CiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gcmVzOwp9OwpSZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247CgpmdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHsKICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7CiAgc2VsZi5yZWFkKDApOwp9CgovLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJCi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS4KUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIGlmICghc3RhdGUuZmxvd2luZykgewogICAgZGVidWcoJ3Jlc3VtZScpOwogICAgc3RhdGUuZmxvd2luZyA9IHRydWU7CiAgICByZXN1bWUodGhpcywgc3RhdGUpOwogIH0KICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHsKICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7CiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7CiAgfQp9CgpmdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnJlYWRpbmcpIHsKICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICB9CgogIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlOwogIHN0YXRlLmF3YWl0RHJhaW4gPSAwOwogIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTsKICBmbG93KHN0cmVhbSk7CiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApOwp9CgpSZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7CiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7CiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdwYXVzZScpOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7CiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7CiAgfQogIHJldHVybiB0aGlzOwp9OwoKZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTsKICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fQp9CgovLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLgovLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuCi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LgpSZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHsKICB2YXIgX3RoaXMgPSB0aGlzOwoKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBwYXVzZWQgPSBmYWxzZTsKCiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7CiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTsKICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkgewogICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpOwogICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTsKICAgIH0KCiAgICBfdGhpcy5wdXNoKG51bGwpOwogIH0pOwoKICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHsKICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTsKICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwoKICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZQogICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuOwoKICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTsKICAgIGlmICghcmV0KSB7CiAgICAgIHBhdXNlZCA9IHRydWU7CiAgICAgIHN0cmVhbS5wYXVzZSgpOwogICAgfQogIH0pOwoKICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuCiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuCiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHsKICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkgewogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpOwogICAgICAgIH07CiAgICAgIH0oaSk7CiAgICB9CiAgfQoKICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuCiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHsKICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpOwogIH0KCiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZQogIC8vIHVuZGVybHlpbmcgc3RyZWFtLgogIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikgewogICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTsKICAgIGlmIChwYXVzZWQpIHsKICAgICAgcGF1c2VkID0gZmFsc2U7CiAgICAgIHN0cmVhbS5yZXN1bWUoKTsKICAgIH0KICB9OwoKICByZXR1cm4gdGhpczsKfTsKCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7CiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGUKICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW4KICAvLyB1c2VybGFuZCB3aWxsIGZhaWwKICBlbnVtZXJhYmxlOiBmYWxzZSwKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7CiAgfQp9KTsKCi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS4KUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7CgovLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuCi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7CiAgLy8gbm90aGluZyBidWZmZXJlZAogIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsOwoKICB2YXIgcmV0OwogIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkgewogICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0CiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7CiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTsKICB9IGVsc2UgewogICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3QKICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykgewogIHZhciByZXQ7CiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHsKICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzCiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTsKICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7CiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHsKICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaAogICAgcmV0ID0gbGlzdC5zaGlmdCgpOwogIH0gZWxzZSB7CiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIKICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpOwogIH0KICByZXR1cm4gcmV0Owp9CgovLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhCi8vIGNodW5rcy4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgewogIHZhciBwID0gbGlzdC5oZWFkOwogIHZhciBjID0gMTsKICB2YXIgcmV0ID0gcC5kYXRhOwogIG4gLT0gcmV0Lmxlbmd0aDsKICB3aGlsZSAocCA9IHAubmV4dCkgewogICAgdmFyIHN0ciA9IHAuZGF0YTsKICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47CiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pOwogICAgbiAtPSBuYjsKICAgIGlmIChuID09PSAwKSB7CiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgewogICAgICAgICsrYzsKICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsOwogICAgICB9IGVsc2UgewogICAgICAgIGxpc3QuaGVhZCA9IHA7CiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTsKICAgICAgfQogICAgICBicmVhazsKICAgIH0KICAgICsrYzsKICB9CiAgbGlzdC5sZW5ndGggLT0gYzsKICByZXR1cm4gcmV0Owp9CgovLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHsKICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pOwogIHZhciBwID0gbGlzdC5oZWFkOwogIHZhciBjID0gMTsKICBwLmRhdGEuY29weShyZXQpOwogIG4gLT0gcC5kYXRhLmxlbmd0aDsKICB3aGlsZSAocCA9IHAubmV4dCkgewogICAgdmFyIGJ1ZiA9IHAuZGF0YTsKICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47CiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7CiAgICBuIC09IG5iOwogICAgaWYgKG4gPT09IDApIHsKICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7CiAgICAgICAgKytjOwogICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbGlzdC5oZWFkID0gcDsKICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgfQogICAgKytjOwogIH0KICBsaXN0Lmxlbmd0aCAtPSBjOwogIHJldHVybiByZXQ7Cn0KCmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkgewogIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKCiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYQogIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi4KICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCciZW5kUmVhZGFibGUoKSIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTsKCiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7CiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7CiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7CiAgfQp9CgpmdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHsKICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC4KICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7CiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTsKICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlOwogICAgc3RyZWFtLmVtaXQoJ2VuZCcpOwogIH0KfQoKZnVuY3Rpb24gaW5kZXhPZih4cywgeCkgewogIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpOwogIH0KICByZXR1cm4gLTE7Cn0KfSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOjEzLCIuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCI6MTgsIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95IjoxOSwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbSI6MjAsIl9wcm9jZXNzIjozMiwiY29yZS11dGlsLWlzIjo3LCJldmVudHMiOjI4LCJpbmhlcml0cyI6OCwiaXNhcnJheSI6OSwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjEyLCJzYWZlLWJ1ZmZlciI6MjIsInN0cmluZ19kZWNvZGVyLyI6MjMsInV0aWwiOjI2fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvCi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgImZpbHRlciIsCi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlCi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGQKLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKQovLwovLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhCi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLAovLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW4KLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLgovLwovLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6Ci8vCi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZQovLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpCi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXMKLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbAovLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuCi8vCi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuCi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlCi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZQovLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdAovLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG8KLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LgovLwovLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsCi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsCi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmcKLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXMKLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueQovLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluCi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbAovLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluCi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbAovLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZAovLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LgovLwovLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rCi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWwKLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuCgondXNlIHN0cmljdCc7Cgptb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTsKCnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgp1dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTsKCmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7CiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7CgogIHZhciBjYiA9IHRzLndyaXRlY2I7CgogIGlmICghY2IpIHsKICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7CiAgfQoKICB0cy53cml0ZWNodW5rID0gbnVsbDsKICB0cy53cml0ZWNiID0gbnVsbDsKCiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgCiAgICB0aGlzLnB1c2goZGF0YSk7CgogIGNiKGVyKTsKCiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICBycy5yZWFkaW5nID0gZmFsc2U7CiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7CiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspOwogIH0KfQoKZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7CgogIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpOwoKICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHsKICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLAogICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsCiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLAogICAgd3JpdGVjYjogbnVsbCwKICAgIHdyaXRlY2h1bms6IG51bGwsCiAgICB3cml0ZWVuY29kaW5nOiBudWxsCiAgfTsKCiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuCiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoKICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3MKICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlCiAgLy8gc3luYyBndWFyZCBmbGFnLgogIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlOwoKICBpZiAob3B0aW9ucykgewogICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7CiAgfQoKICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuCiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTsKfQoKZnVuY3Rpb24gcHJlZmluaXNoKCkgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHsKICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkgewogICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7CiAgICB9KTsKICB9IGVsc2UgewogICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTsKICB9Cn0KClRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHsKICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7CiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7Cn07CgovLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiEKLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLgovLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLgovLwovLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXQKLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy4KLy8KLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3MKLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdQovLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLgpUcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpOwp9OwoKVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwogIHRzLndyaXRlY2IgPSBjYjsKICB0cy53cml0ZWNodW5rID0gY2h1bms7CiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nOwogIGlmICghdHMudHJhbnNmb3JtaW5nKSB7CiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7CiAgfQp9OwoKLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS4KLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay4KLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS4KVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7CiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CgogIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykgewogICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTsKICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7CiAgfSBlbHNlIHsKICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW4KICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LgogICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7CiAgfQp9OwoKVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdmFyIF90aGlzMiA9IHRoaXM7CgogIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7CiAgICBjYihlcnIyKTsKICAgIF90aGlzMi5lbWl0KCdjbG9zZScpOwogIH0pOwp9OwoKZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7CiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwoKICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAKICAgIHN0cmVhbS5wdXNoKGRhdGEpOwoKICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zCiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkCiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7CgogIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7CgogIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTsKfQp9LHsiLi9fc3RyZWFtX2R1cGxleCI6MTMsImNvcmUtdXRpbC1pcyI6NywiaW5oZXJpdHMiOjh9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsc2V0SW1tZWRpYXRlKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuCi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbAovLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy4KCid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgptb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlOwoKLyogPHJlcGxhY2VtZW50PiAqLwpmdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdGhpcy5jaHVuayA9IGNodW5rOwogIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZzsKICB0aGlzLmNhbGxiYWNrID0gY2I7CiAgdGhpcy5uZXh0ID0gbnVsbDsKfQoKLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90Ci8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbQpmdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7CiAgdmFyIF90aGlzID0gdGhpczsKCiAgdGhpcy5uZXh0ID0gbnVsbDsKICB0aGlzLmVudHJ5ID0gbnVsbDsKICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHsKICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7CiAgfTsKfQovKiA8L3JlcGxhY2VtZW50PiAqLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljazsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgRHVwbGV4OwovKjwvcmVwbGFjZW1lbnQ+Ki8KCldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIGludGVybmFsVXRpbCA9IHsKICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJykKfTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7CnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307CmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHsKICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspOwp9CmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7CiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7Cn0KCi8qPC9yZXBsYWNlbWVudD4qLwoKdmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTsKCnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7CgpmdW5jdGlvbiBub3AoKSB7fQoKZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpOwoKICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmUKICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC4KICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudAogIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uCiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguCiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OwoKICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW0KICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuCiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CgogIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7CgogIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2UKICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZgogIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKCkKICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrOwogIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrOwogIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7CgogIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtOwoKICAvLyBjYXN0IHRvIGludHMuCiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspOwoKICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkCiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOwoKICAvLyBkcmFpbiBldmVudCBmbGFnLgogIHRoaXMubmVlZERyYWluID0gZmFsc2U7CiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKCkKICB0aGlzLmVuZGluZyA9IGZhbHNlOwogIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWQKICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkCiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOwoKICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWQKICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOwoKICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT8KICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmcKICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLgogIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7CiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOwoKICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nCiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLgogIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC4KICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsKCiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnQKICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nCiAgLy8gc29ja2V0IG9yIGZpbGUuCiAgdGhpcy5sZW5ndGggPSAwOwoKICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLgogIHRoaXMud3JpdGluZyA9IGZhbHNlOwoKICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsCiAgdGhpcy5jb3JrZWQgPSAwOwoKICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwKICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueQogIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsICJsYXRlciIgc2hvdWxkIGdlbmVyYWxseSBhbHNvCiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuCiAgdGhpcy5zeW5jID0gdHJ1ZTsKCiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaAogIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0CiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uCiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7CgogIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYikKICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHsKICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7CiAgfTsKCiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpCiAgdGhpcy53cml0ZWNiID0gbnVsbDsKCiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLgogIHRoaXMud3JpdGVsZW4gPSAwOwoKICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKCiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3MKICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWQKICB0aGlzLnBlbmRpbmdjYiA9IDA7CgogIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnMKICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtcwogIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsKCiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW4KICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOwoKICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0cwogIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOwoKICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzCiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3bwogIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7Cn0KCldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHsKICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0OwogIHZhciBvdXQgPSBbXTsKICB3aGlsZSAoY3VycmVudCkgewogICAgb3V0LnB1c2goY3VycmVudCk7CiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0OwogIH0KICByZXR1cm4gb3V0Owp9OwoKKGZ1bmN0aW9uICgpIHsKICB0cnkgewogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywgewogICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpOwogICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJykKICAgIH0pOwogIH0gY2F0Y2ggKF8pIHt9Cn0pKCk7CgovLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcywKLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLgp2YXIgcmVhbEhhc0luc3RhbmNlOwppZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7CiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7CiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTsKICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7CgogICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7CiAgICB9CiAgfSk7Cn0gZWxzZSB7CiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkgewogICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7CiAgfTsKfQoKZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykgewogIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLgogIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYAogIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC4KCiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlCiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yCiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLgogIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHsKICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7CiAgfQoKICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7CgogIC8vIGxlZ2FjeS4KICB0aGlzLndyaXRhYmxlID0gdHJ1ZTsKCiAgaWYgKG9wdGlvbnMpIHsKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlOwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2OwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95OwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsOwogIH0KCiAgU3RyZWFtLmNhbGwodGhpcyk7Cn0KCi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy4KV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7CiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTsKfTsKCmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikgewogIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7CiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2IKICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgcG5hLm5leHRUaWNrKGNiLCBlcik7Cn0KCi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXIKLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZAovLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuCmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7CiAgdmFyIHZhbGlkID0gdHJ1ZTsKICB2YXIgZXIgPSBmYWxzZTsKCiAgaWYgKGNodW5rID09PSBudWxsKSB7CiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7CiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpOwogIH0KICBpZiAoZXIpIHsKICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICAgIHBuYS5uZXh0VGljayhjYiwgZXIpOwogICAgdmFsaWQgPSBmYWxzZTsKICB9CiAgcmV0dXJuIHZhbGlkOwp9CgpXcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgdmFyIHJldCA9IGZhbHNlOwogIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspOwoKICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHsKICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7CiAgfQoKICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7CiAgICBjYiA9IGVuY29kaW5nOwogICAgZW5jb2RpbmcgPSBudWxsOwogIH0KCiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7CgogIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wOwoKICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHsKICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpOwogIH0KCiAgcmV0dXJuIHJldDsKfTsKCldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgogIHN0YXRlLmNvcmtlZCsrOwp9OwoKV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlOwoKICBpZiAoc3RhdGUuY29ya2VkKSB7CiAgICBzdGF0ZS5jb3JrZWQtLTsKCiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7CiAgfQp9OwoKV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykgewogIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLgogIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7CiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTsKICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nOwogIHJldHVybiB0aGlzOwp9OwoKZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykgewogIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7CiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgfQogIHJldHVybiBjaHVuazsKfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHsKICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZQogIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpbgogIC8vIHVzZXJsYW5kIHdpbGwgZmFpbAogIGVudW1lcmFibGU6IGZhbHNlLAogIGdldDogZnVuY3Rpb24gKCkgewogICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyazsKICB9Cn0pOwoKLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzCi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlCi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuCmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBpZiAoIWlzQnVmKSB7CiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTsKICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHsKICAgICAgaXNCdWYgPSB0cnVlOwogICAgICBlbmNvZGluZyA9ICdidWZmZXInOwogICAgICBjaHVuayA9IG5ld0NodW5rOwogICAgfQogIH0KICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CgogIHN0YXRlLmxlbmd0aCArPSBsZW47CgogIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOwogIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLgogIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlOwoKICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHsKICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7CiAgICAgIGNodW5rOiBjaHVuaywKICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLAogICAgICBpc0J1ZjogaXNCdWYsCiAgICAgIGNhbGxiYWNrOiBjYiwKICAgICAgbmV4dDogbnVsbAogICAgfTsKICAgIGlmIChsYXN0KSB7CiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICB9IGVsc2UgewogICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgfQogICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTsKICB9IGVsc2UgewogICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBzdGF0ZS53cml0ZWxlbiA9IGxlbjsKICBzdGF0ZS53cml0ZWNiID0gY2I7CiAgc3RhdGUud3JpdGluZyA9IHRydWU7CiAgc3RhdGUuc3luYyA9IHRydWU7CiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpOwogIHN0YXRlLnN5bmMgPSBmYWxzZTsKfQoKZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikgewogIC0tc3RhdGUucGVuZGluZ2NiOwoKICBpZiAoc3luYykgewogICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseQogICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2sKICAgIHBuYS5uZXh0VGljayhjYiwgZXIpOwogICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW4KICAgIC8vIGFmdGVyIGVycm9yCiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpOwogICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgfSBlbHNlIHsKICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZgogICAgLy8gaXQgaXMgYXN5bmMKICAgIGNiKGVyKTsKICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwogICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdAogICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvcgogICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgfQp9CgpmdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHsKICBzdGF0ZS53cml0aW5nID0gZmFsc2U7CiAgc3RhdGUud3JpdGVjYiA9IG51bGw7CiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuOwogIHN0YXRlLndyaXRlbGVuID0gMDsKfQoKZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlOwogIHZhciBzeW5jID0gc3RhdGUuc3luYzsKICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiOwoKICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpOwoKICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2UgewogICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXQKICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpOwoKICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHsKICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7CiAgICB9CgogICAgaWYgKHN5bmMpIHsKICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki8KICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpOwogICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki8KICAgIH0gZWxzZSB7CiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTsKICAgIH0KICB9Cn0KCmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7CiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpOwogIHN0YXRlLnBlbmRpbmdjYi0tOwogIGNiKCk7CiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7Cn0KCi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0Ci8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm4KLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci4KZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikgewogICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7CiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTsKICB9Cn0KCi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0CmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHsKICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTsKICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7CgogIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7CiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpCiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50OwogICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTsKICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7CiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTsKCiAgICB2YXIgY291bnQgPSAwOwogICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlOwogICAgd2hpbGUgKGVudHJ5KSB7CiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTsKICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlOwogICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgICAgIGNvdW50ICs9IDE7CiAgICB9CiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7CgogICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOwoKICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lCiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGUKICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgICBpZiAoaG9sZGVyLm5leHQpIHsKICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7CiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTsKICAgIH0KICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsKICB9IGVsc2UgewogICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZQogICAgd2hpbGUgKGVudHJ5KSB7CiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rOwogICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZzsKICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7CiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKCiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsKICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW4KICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy4KICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseQogICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS4KICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgfQoKICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTsKICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7Cn0KCldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpOwp9OwoKV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsOwoKV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBjaHVuazsKICAgIGNodW5rID0gbnVsbDsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBlbmNvZGluZzsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9CgogIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7CgogIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzCiAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgc3RhdGUuY29ya2VkID0gMTsKICAgIHRoaXMudW5jb3JrKCk7CiAgfQoKICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuCiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpOwp9OwoKZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkgewogIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7Cn0KZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHsKICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHsKICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgaWYgKGVycikgewogICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpOwogICAgfQogICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlOwogICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpOwogICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgfSk7Cn0KZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkgewogICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7CiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpOwogICAgfSBlbHNlIHsKICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlOwogICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7CiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTsKICBpZiAobmVlZCkgewogICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpOwogICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkgewogICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7CiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTsKICAgIH0KICB9CiAgcmV0dXJuIG5lZWQ7Cn0KCmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7CiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTsKICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICBpZiAoY2IpIHsKICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7CiAgfQogIHN0YXRlLmVuZGVkID0gdHJ1ZTsKICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTsKfQoKZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikgewogIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7CiAgY29ya1JlcS5lbnRyeSA9IG51bGw7CiAgd2hpbGUgKGVudHJ5KSB7CiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgY2IoZXJyKTsKICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICB9CiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkgewogICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxOwogIH0gZWxzZSB7CiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxOwogIH0KfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOwogIH0sCiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsKICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbQogICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldAogICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5CiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgfQp9KTsKCldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTsKV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7CldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdGhpcy5lbmQoKTsKICBjYihlcnIpOwp9Owp9KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoInRpbWVycyIpLnNldEltbWVkaWF0ZSkKfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOjEzLCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveSI6MTksIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0iOjIwLCJfcHJvY2VzcyI6MzIsImNvcmUtdXRpbC1pcyI6NywiaW5oZXJpdHMiOjgsInByb2Nlc3MtbmV4dGljay1hcmdzIjoxMiwic2FmZS1idWZmZXIiOjIyLCJ0aW1lcnMiOjMzLCJ1dGlsLWRlcHJlY2F0ZSI6MjR9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7IH0gfQoKdmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwp2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTsKCmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkgewogIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTsKfQoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHsKICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTsKCiAgICB0aGlzLmhlYWQgPSBudWxsOwogICAgdGhpcy50YWlsID0gbnVsbDsKICAgIHRoaXMubGVuZ3RoID0gMDsKICB9CgogIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHsKICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9OwogICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5OwogICAgdGhpcy50YWlsID0gZW50cnk7CiAgICArK3RoaXMubGVuZ3RoOwogIH07CgogIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHsKICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5OwogICAgdGhpcy5oZWFkID0gZW50cnk7CiAgICArK3RoaXMubGVuZ3RoOwogIH07CgogIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjsKICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0OwogICAgLS10aGlzLmxlbmd0aDsKICAgIHJldHVybiByZXQ7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHsKICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICB0aGlzLmxlbmd0aCA9IDA7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykgewogICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7CiAgICB2YXIgcCA9IHRoaXMuaGVhZDsKICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTsKICAgIHdoaWxlIChwID0gcC5uZXh0KSB7CiAgICAgIHJldCArPSBzICsgcC5kYXRhOwogICAgfXJldHVybiByZXQ7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhOwogICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTsKICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgdmFyIGkgPSAwOwogICAgd2hpbGUgKHApIHsKICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7CiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDsKICAgICAgcCA9IHAubmV4dDsKICAgIH0KICAgIHJldHVybiByZXQ7CiAgfTsKCiAgcmV0dXJuIEJ1ZmZlckxpc3Q7Cn0oKTsKCmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7CiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkgewogICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7CiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqOwogIH07Cn0KfSx7InNhZmUtYnVmZmVyIjoyMiwidXRpbCI6MjZ9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJCmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKCiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7CiAgICBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7CiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTsKICAgIH0KICAgIHJldHVybiB0aGlzOwogIH0KCiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyCiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzCgogIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7CiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7CiAgfQoKICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsCiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTsKICB9CgogIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHsKICAgIGlmICghY2IgJiYgZXJyKSB7CiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7CiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0KICB9KTsKCiAgcmV0dXJuIHRoaXM7Cn0KCmZ1bmN0aW9uIHVuZGVzdHJveSgpIHsKICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7CiAgfQoKICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlOwogIH0KfQoKZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7CiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7Cn0KCm1vZHVsZS5leHBvcnRzID0gewogIGRlc3Ryb3k6IGRlc3Ryb3ksCiAgdW5kZXN0cm95OiB1bmRlc3Ryb3kKfTsKfSx7InByb2Nlc3MtbmV4dGljay1hcmdzIjoxMn1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7Cgp9LHsiZXZlbnRzIjoyOH1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpOwpleHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7CmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzOwpleHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpOwpleHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7CmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTsKZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX2R1cGxleC5qcyI6MTMsIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiOjE0LCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIjoxNSwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiOjE2LCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIjoxN31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqLwp2YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykKdmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXIKCi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnMKZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkgewogIGZvciAodmFyIGtleSBpbiBzcmMpIHsKICAgIGRzdFtrZXldID0gc3JjW2tleV0KICB9Cn0KaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykgewogIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyCn0gZWxzZSB7CiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJykKICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKQogIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlcgp9CgpmdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KCi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXIKY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcikKClNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKQogIH0KICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQp9CgpTYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCiAgfQogIHZhciBidWYgPSBCdWZmZXIoc2l6ZSkKICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7CiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgewogICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZykKICAgIH0gZWxzZSB7CiAgICAgIGJ1Zi5maWxsKGZpbGwpCiAgICB9CiAgfSBlbHNlIHsKICAgIGJ1Zi5maWxsKDApCiAgfQogIHJldHVybiBidWYKfQoKU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCiAgfQogIHJldHVybiBCdWZmZXIoc2l6ZSkKfQoKU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0KICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSkKfQoKfSx7ImJ1ZmZlciI6Mjd9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7Ci8qPC9yZXBsYWNlbWVudD4qLwoKdmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHsKICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7CiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7CiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzoKICAgICAgcmV0dXJuIHRydWU7CiAgICBkZWZhdWx0OgogICAgICByZXR1cm4gZmFsc2U7CiAgfQp9OwoKZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykgewogIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnOwogIHZhciByZXRyaWVkOwogIHdoaWxlICh0cnVlKSB7CiAgICBzd2l0Y2ggKGVuYykgewogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiAndXRmOCc7CiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuICd1dGYxNmxlJzsKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gJ2xhdGluMSc7CiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gZW5jOwogICAgICBkZWZhdWx0OgogICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZAogICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTsKICAgICAgICByZXRyaWVkID0gdHJ1ZTsKICAgIH0KICB9Cn07CgovLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWUKLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5ncwpmdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHsKICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpOwogIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpOwogIHJldHVybiBuZW5jIHx8IGVuYzsKfQoKLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZgovLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGUKLy8gY2hhcmFjdGVycy4KZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjsKZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykgewogIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7CiAgdmFyIG5iOwogIHN3aXRjaCAodGhpcy5lbmNvZGluZykgewogICAgY2FzZSAndXRmMTZsZSc6CiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDsKICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDsKICAgICAgbmIgPSA0OwogICAgICBicmVhazsKICAgIGNhc2UgJ3V0ZjgnOgogICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0OwogICAgICBuYiA9IDQ7CiAgICAgIGJyZWFrOwogICAgY2FzZSAnYmFzZTY0JzoKICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDsKICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7CiAgICAgIG5iID0gMzsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7CiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kOwogICAgICByZXR1cm47CiAgfQogIHRoaXMubGFzdE5lZWQgPSAwOwogIHRoaXMubGFzdFRvdGFsID0gMDsKICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTsKfQoKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7CiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJzsKICB2YXIgcjsKICB2YXIgaTsKICBpZiAodGhpcy5sYXN0TmVlZCkgewogICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTsKICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJzsKICAgIGkgPSB0aGlzLmxhc3ROZWVkOwogICAgdGhpcy5sYXN0TmVlZCA9IDA7CiAgfSBlbHNlIHsKICAgIGkgPSAwOwogIH0KICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7CiAgcmV0dXJuIHIgfHwgJyc7Cn07CgpTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kOwoKLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0OwoKLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlcgpTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHsKICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpOwogICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwogIH0KICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpOwogIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKfTsKCi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGEKLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuCmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkgewogIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0OwogIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yOwp9CgovLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuCi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpCi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuCmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7CiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTsKICBpZiAoaiA8IGkpIHJldHVybiAwOwogIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICBpZiAobmIgPj0gMCkgewogICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTsKICAgIHJldHVybiBuYjsKICB9CiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDsKICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICBpZiAobmIgPj0gMCkgewogICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjsKICAgIHJldHVybiBuYjsKICB9CiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDsKICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICBpZiAobmIgPj0gMCkgewogICAgaWYgKG5iID4gMCkgewogICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7CiAgICB9CiAgICByZXR1cm4gbmI7CiAgfQogIHJldHVybiAwOwp9CgovLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXMKLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3QKLy8gb25lLCB3ZSAicmVwbGFjZSIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aAovLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZwovLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlCi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuCi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGEKLy8gbG9vcC4KZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHsKICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7CiAgICBzZWxmLmxhc3ROZWVkID0gMDsKICAgIHJldHVybiAnXHVmZmZkJzsKICB9CiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7CiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7CiAgICAgIHNlbGYubGFzdE5lZWQgPSAxOwogICAgICByZXR1cm4gJ1x1ZmZmZCc7CiAgICB9CiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHsKICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgICAgIHNlbGYubGFzdE5lZWQgPSAyOwogICAgICAgIHJldHVybiAnXHVmZmZkJzsKICAgICAgfQogICAgfQogIH0KfQoKLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLgpmdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7CiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7CiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7CiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7CiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewogICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7CiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7CiAgfQogIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpOwogIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKfQoKLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhCi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZAovLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS4KZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7CiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpOwogIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpOwogIHRoaXMubGFzdFRvdGFsID0gdG90YWw7CiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTsKICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpOwogIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpOwp9CgovLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbAovLyBjaGFyYWN0ZXIuCmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7CiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwogIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcdWZmZmQnOwogIHJldHVybiByOwp9CgovLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlbgovLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaAovLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG8KLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS4KZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkgewogIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkgewogICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTsKICAgIGlmIChyKSB7CiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7CiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikgewogICAgICAgIHRoaXMubGFzdE5lZWQgPSAyOwogICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDsKICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTsKICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByOwogIH0KICB0aGlzLmxhc3ROZWVkID0gMTsKICB0aGlzLmxhc3RUb3RhbCA9IDI7CiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTsKfQoKLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2UKLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuCmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1ZikgewogIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKICBpZiAodGhpcy5sYXN0TmVlZCkgewogICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7CiAgfQogIHJldHVybiByOwp9CgpmdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkgewogIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7CiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpOwogIHRoaXMubGFzdE5lZWQgPSAzIC0gbjsKICB0aGlzLmxhc3RUb3RhbCA9IDM7CiAgaWYgKG4gPT09IDEpIHsKICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogIH0gZWxzZSB7CiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTsKICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogIH0KICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7Cn0KCmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHsKICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpOwogIHJldHVybiByOwp9CgovLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpCmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1ZikgewogIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7Cn0KCmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHsKICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKfQp9LHsic2FmZS1idWZmZXIiOjIyfV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKGdsb2JhbCl7CgovKioKICogTW9kdWxlIGV4cG9ydHMuCiAqLwoKbW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7CgovKioKICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC4KICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC4KICoKICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuCiAqCiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9ucwogKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC4KICoKICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zCiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuCiAqCiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZQogKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZAogKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3ICJkZXByZWNhdGVkIiB2ZXJzaW9uIG9mIGBmbmAKICogQGFwaSBwdWJsaWMKICovCgpmdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHsKICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHsKICAgIHJldHVybiBmbjsKICB9CgogIHZhciB3YXJuZWQgPSBmYWxzZTsKICBmdW5jdGlvbiBkZXByZWNhdGVkKCkgewogICAgaWYgKCF3YXJuZWQpIHsKICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7CiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHsKICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7CiAgICAgIH0KICAgICAgd2FybmVkID0gdHJ1ZTsKICAgIH0KICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogIH0KCiAgcmV0dXJuIGRlcHJlY2F0ZWQ7Cn0KCi8qKgogKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLgogKgogKiBAcGFyYW0ge1N0cmluZ30gbmFtZQogKiBAcmV0dXJucyB7Qm9vbGVhbn0KICogQGFwaSBwcml2YXRlCiAqLwoKZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7CiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXMKICB0cnkgewogICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7CiAgfSBjYXRjaCAoXykgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTsKICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTsKICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnOwp9Cgp9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCcKCmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGgKZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5CmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXkKCnZhciBsb29rdXAgPSBbXQp2YXIgcmV2TG9va3VwID0gW10KdmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheQoKdmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycKZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHsKICBsb29rdXBbaV0gPSBjb2RlW2ldCiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpCn0KCi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy4KLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9ucwpyZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjIKcmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzCgpmdW5jdGlvbiBnZXRMZW5zIChiNjQpIHsKICB2YXIgbGVuID0gYjY0Lmxlbmd0aAoKICBpZiAobGVuICUgNCA+IDApIHsKICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpCiAgfQoKICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmQKICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDIKICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpCiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW4KCiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4KICAgID8gMAogICAgOiA0IC0gKHZhbGlkTGVuICUgNCkKCiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXQp9CgovLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGEKZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7CiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NCkKICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdCiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV0KICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW4KfQoKZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikgewogIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlbgp9CgpmdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7CiAgdmFyIHRtcAogIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpCiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXQogIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdCgogIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpCgogIHZhciBjdXJCeXRlID0gMAoKICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzCiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDAKICAgID8gdmFsaWRMZW4gLSA0CiAgICA6IHZhbGlkTGVuCgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgIHRtcCA9CiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8CiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfAogICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfAogICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXQogICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkYKICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkYKICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRgogIH0KCiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikgewogICAgdG1wID0KICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfAogICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNCkKICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRgogIH0KCiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkgewogICAgdG1wID0KICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwKICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwKICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpCiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGCiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkYKICB9CgogIHJldHVybiBhcnIKfQoKZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHsKICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsKICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArCiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArCiAgICBsb29rdXBbbnVtICYgMHgzRl0KfQoKZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7CiAgdmFyIHRtcAogIHZhciBvdXRwdXQgPSBbXQogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7CiAgICB0bXAgPQogICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArCiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArCiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKQogICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpCiAgfQogIHJldHVybiBvdXRwdXQuam9pbignJykKfQoKZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHsKICB2YXIgdG1wCiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aAogIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlcwogIHZhciBwYXJ0cyA9IFtdCiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzCgogIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXIKICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKAogICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpCiAgICApKQogIH0KCiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlcwogIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXQogICAgcGFydHMucHVzaCgKICAgICAgbG9va3VwW3RtcCA+PiAyXSArCiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gKwogICAgICAnPT0nCiAgICApCiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7CiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXQogICAgcGFydHMucHVzaCgKICAgICAgbG9va3VwW3RtcCA+PiAxMF0gKwogICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICsKICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArCiAgICAgICc9JwogICAgKQogIH0KCiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpCn0KCn0se31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKCn0se31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKLyohCiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwovKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqLwoKJ3VzZSBzdHJpY3QnCgp2YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJykKdmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JykKCmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyCmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXIKZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwCgp2YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZgpleHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEgKCi8qKgogKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOgogKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KQogKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3QKICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNikKICoKICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLAogKiBPcGVyYSAxMS42KywgaU9TIDQuMisuCiAqCiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZQogKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgCiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnQKICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uCiAqLwpCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KCkKCmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmCiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykgewogIGNvbnNvbGUuZXJyb3IoCiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgKwogICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJwogICkKfQoKZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkgewogIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD8KICB0cnkgewogICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpCiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX0KICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyCiAgfSBjYXRjaCAoZSkgewogICAgcmV0dXJuIGZhbHNlCiAgfQp9CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7CiAgICAgIHJldHVybiB1bmRlZmluZWQKICAgIH0KICAgIHJldHVybiB0aGlzLmJ1ZmZlcgogIH0KfSkKCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0JywgewogIGdldDogZnVuY3Rpb24gKCkgewogICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHsKICAgICAgcmV0dXJuIHVuZGVmaW5lZAogICAgfQogICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldAogIH0KfSkKCmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7CiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJykKICB9CiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UKICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKQogIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlCiAgcmV0dXJuIGJ1Zgp9CgovKioKICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyCiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2YKICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kcwogKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdAogKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LgogKgogKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuCiAqLwoKZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIC8vIENvbW1vbiBjYXNlLgogIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykgewogICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJwogICAgICApCiAgICB9CiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKQogIH0KICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTcKaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmCiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywgewogICAgdmFsdWU6IG51bGwsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgIHdyaXRhYmxlOiBmYWxzZQogIH0pCn0KCkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbgoKZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJykKICB9CgogIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSB8fCAodmFsdWUgJiYgaXNBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSkgewogICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQogIH0KCiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsKICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KQogIH0KCiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpCn0KCi8qKgogKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvcgogKiBpZiB2YWx1ZSBpcyBhIG51bWJlci4KICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKQogKiBCdWZmZXIuZnJvbShhcnJheSkKICogQnVmZmVyLmZyb20oYnVmZmVyKQogKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSkKICoqLwpCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOgovLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OApCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlCkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5CgpmdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKQogIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKQogIH0KfQoKZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgYXNzZXJ0U2l6ZShzaXplKQogIGlmIChzaXplIDw9IDApIHsKICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSkKICB9CiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkgewogICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXMKICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGQKICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC4KICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnCiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpCiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCkKICB9CiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKQp9CgovKioKICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLgogKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pCiAqKi8KQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKQp9CgpmdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkgewogIGFzc2VydFNpemUoc2l6ZSkKICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKQp9CgovKioKICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS4KICogKi8KQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHsKICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSkKfQovKioKICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuCiAqLwpCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHsKICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSkKfQoKZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykgewogIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgewogICAgZW5jb2RpbmcgPSAndXRmOCcKICB9CgogIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgfQoKICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDAKICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aCkKCiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKQoKICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHsKICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbAogICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy4KICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKQogICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbCkKICB9CgogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHsKICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwCiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkgewogICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTUKICB9CiAgcmV0dXJuIGJ1Zgp9CgpmdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHsKICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcib2Zmc2V0IiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKQogIH0KCiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJsZW5ndGgiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpCiAgfQoKICB2YXIgYnVmCiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkgewogICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpCiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgewogICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpCiAgfSBlbHNlIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpCiAgfQoKICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZQogIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlCiAgcmV0dXJuIGJ1Zgp9CgpmdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHsKICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHsKICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMAogICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pCgogICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIGJ1ZgogICAgfQoKICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKQogICAgcmV0dXJuIGJ1ZgogIH0KCiAgaWYgKG9iaikgewogICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikgewogICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKQogICAgICB9CiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iaikKICAgIH0KCiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7CiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKQogICAgfQogIH0KCiAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuJykKfQoKZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7CiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuCiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pCiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgKwogICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJykKICB9CiAgcmV0dXJuIGxlbmd0aCB8IDAKfQoKZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7CiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxCiAgICBsZW5ndGggPSAwCiAgfQogIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aCkKfQoKQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHsKICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlCn0KCkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikgewogIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKQogIH0KCiAgaWYgKGEgPT09IGIpIHJldHVybiAwCgogIHZhciB4ID0gYS5sZW5ndGgKICB2YXIgeSA9IGIubGVuZ3RoCgogIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7CiAgICBpZiAoYVtpXSAhPT0gYltpXSkgewogICAgICB4ID0gYVtpXQogICAgICB5ID0gYltpXQogICAgICBicmVhawogICAgfQogIH0KCiAgaWYgKHggPCB5KSByZXR1cm4gLTEKICBpZiAoeSA8IHgpIHJldHVybiAxCiAgcmV0dXJuIDAKfQoKQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykgewogIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7CiAgICBjYXNlICdoZXgnOgogICAgY2FzZSAndXRmOCc6CiAgICBjYXNlICd1dGYtOCc6CiAgICBjYXNlICdhc2NpaSc6CiAgICBjYXNlICdsYXRpbjEnOgogICAgY2FzZSAnYmluYXJ5JzoKICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICBjYXNlICd1Y3MyJzoKICAgIGNhc2UgJ3Vjcy0yJzoKICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgY2FzZSAndXRmLTE2bGUnOgogICAgICByZXR1cm4gdHJ1ZQogICAgZGVmYXVsdDoKICAgICAgcmV0dXJuIGZhbHNlCiAgfQp9CgpCdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHsKICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKQogIH0KCiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7CiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApCiAgfQoKICB2YXIgaQogIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkgewogICAgbGVuZ3RoID0gMAogICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHsKICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoCiAgICB9CiAgfQoKICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aCkKICB2YXIgcG9zID0gMAogIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICB2YXIgYnVmID0gbGlzdFtpXQogICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhidWYpKSB7CiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZikKICAgIH0KICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpCiAgICB9CiAgICBidWYuY29weShidWZmZXIsIHBvcykKICAgIHBvcyArPSBidWYubGVuZ3RoCiAgfQogIHJldHVybiBidWZmZXIKfQoKZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykgewogIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkgewogICAgcmV0dXJuIHN0cmluZy5sZW5ndGgKICB9CiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzQXJyYXlCdWZmZXIoc3RyaW5nKSkgewogICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoCiAgfQogIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykgewogICAgc3RyaW5nID0gJycgKyBzdHJpbmcKICB9CgogIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoCiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDAKCiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uCiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKICBmb3IgKDs7KSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGVuCiAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICBjYXNlICd1dGYtOCc6CiAgICAgIGNhc2UgdW5kZWZpbmVkOgogICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aAogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiBsZW4gKiAyCiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMQogICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjgKICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aAoKZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkgewogIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlCgogIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzIiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHkKICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LgoKICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmQKICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuCiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbiwKICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi4KICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHsKICAgIHN0YXJ0ID0gMAogIH0KICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMgogIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuCiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHsKICAgIHJldHVybiAnJwogIH0KCiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7CiAgICBlbmQgPSB0aGlzLmxlbmd0aAogIH0KCiAgaWYgKGVuZCA8PSAwKSB7CiAgICByZXR1cm4gJycKICB9CgogIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuCiAgZW5kID4+Pj0gMAogIHN0YXJ0ID4+Pj0gMAoKICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICByZXR1cm4gJycKICB9CgogIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnCgogIHdoaWxlICh0cnVlKSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKQogICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZQogICAgfQogIH0KfQoKLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKQovLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgCi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50Ci8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlcgovLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuCi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NApCdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWUKCmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHsKICB2YXIgaSA9IGJbbl0KICBiW25dID0gYlttXQogIGJbbV0gPSBpCn0KCkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBpZiAobGVuICUgMiAhPT0gMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJykKICB9CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikgewogICAgc3dhcCh0aGlzLCBpLCBpICsgMSkKICB9CiAgcmV0dXJuIHRoaXMKfQoKQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIGlmIChsZW4gJSA0ICE9PSAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7CiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKQogICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpCiAgfQogIHJldHVybiB0aGlzCn0KCkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHsKICB2YXIgbGVuID0gdGhpcy5sZW5ndGgKICBpZiAobGVuICUgOCAhPT0gMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJykKICB9CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkgewogICAgc3dhcCh0aGlzLCBpLCBpICsgNykKICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KQogICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpCiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNCkKICB9CiAgcmV0dXJuIHRoaXMKfQoKQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHsKICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgKICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJycKICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpCiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpCn0KCkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nCgpCdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikgewogIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWUKICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDAKfQoKQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7CiAgdmFyIHN0ciA9ICcnCiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMKICBpZiAodGhpcy5sZW5ndGggPiAwKSB7CiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKQogICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJwogIH0KICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+Jwp9CgpCdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkgewogIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKQogIH0KCiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHsKICAgIHN0YXJ0ID0gMAogIH0KICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHsKICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwCiAgfQogIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkgewogICAgdGhpc1N0YXJ0ID0gMAogIH0KICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7CiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGgKICB9CgogIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpCiAgfQoKICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7CiAgICByZXR1cm4gMAogIH0KICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHsKICAgIHJldHVybiAtMQogIH0KICBpZiAoc3RhcnQgPj0gZW5kKSB7CiAgICByZXR1cm4gMQogIH0KCiAgc3RhcnQgPj4+PSAwCiAgZW5kID4+Pj0gMAogIHRoaXNTdGFydCA+Pj49IDAKICB0aGlzRW5kID4+Pj0gMAoKICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMAoKICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQKICB2YXIgeSA9IGVuZCAtIHN0YXJ0CiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpCgogIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKQogIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpCgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHsKICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkgewogICAgICB4ID0gdGhpc0NvcHlbaV0KICAgICAgeSA9IHRhcmdldENvcHlbaV0KICAgICAgYnJlYWsKICAgIH0KICB9CgogIGlmICh4IDwgeSkgcmV0dXJuIC0xCiAgaWYgKHkgPCB4KSByZXR1cm4gMQogIHJldHVybiAwCn0KCi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCwKLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC4KLy8KLy8gQXJndW1lbnRzOgovLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaAovLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlcgovLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzIKLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmcKLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2YKZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7CiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoCiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMQoKICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldAogIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHsKICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldAogICAgYnl0ZU9mZnNldCA9IDAKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7CiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZgogIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7CiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDAKICB9CiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLgogIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkgewogICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgImZvbyIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlcgogICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpCiAgfQoKICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlcgogIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0CiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgewogICAgaWYgKGRpcikgcmV0dXJuIC0xCiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMQogIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHsKICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwCiAgICBlbHNlIHJldHVybiAtMQogIH0KCiAgLy8gTm9ybWFsaXplIHZhbAogIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgewogICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZykKICB9CgogIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mCiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7CiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzCiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkgewogICAgICByZXR1cm4gLTEKICAgIH0KICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpCiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykgewogICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdCiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHsKICAgICAgaWYgKGRpcikgewogICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpCiAgICAgIH0KICAgIH0KICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKQogIH0KCiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJykKfQoKZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogIHZhciBpbmRleFNpemUgPSAxCiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGgKICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aAoKICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgewogICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkKICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8CiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykgewogICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHsKICAgICAgICByZXR1cm4gLTEKICAgICAgfQogICAgICBpbmRleFNpemUgPSAyCiAgICAgIGFyckxlbmd0aCAvPSAyCiAgICAgIHZhbExlbmd0aCAvPSAyCiAgICAgIGJ5dGVPZmZzZXQgLz0gMgogICAgfQogIH0KCiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7CiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7CiAgICAgIHJldHVybiBidWZbaV0KICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpCiAgICB9CiAgfQoKICB2YXIgaQogIGlmIChkaXIpIHsKICAgIHZhciBmb3VuZEluZGV4ID0gLTEKICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykgewogICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7CiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaQogICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemUKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXgKICAgICAgICBmb3VuZEluZGV4ID0gLTEKICAgICAgfQogICAgfQogIH0gZWxzZSB7CiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aAogICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHsKICAgICAgdmFyIGZvdW5kID0gdHJ1ZQogICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7CiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkgewogICAgICAgICAgZm91bmQgPSBmYWxzZQogICAgICAgICAgYnJlYWsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaQogICAgfQogIH0KCiAgcmV0dXJuIC0xCn0KCkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xCn0KCkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSkKfQoKQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKQp9CgpmdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMAogIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0CiAgaWYgKCFsZW5ndGgpIHsKICAgIGxlbmd0aCA9IHJlbWFpbmluZwogIH0gZWxzZSB7CiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKQogICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykgewogICAgICBsZW5ndGggPSByZW1haW5pbmcKICAgIH0KICB9CgogIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoCgogIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7CiAgICBsZW5ndGggPSBzdHJMZW4gLyAyCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpCiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGkKICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZAogIH0KICByZXR1cm4gaQp9CgpmdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCn0KCmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKQogIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgewogICAgZW5jb2RpbmcgPSAndXRmOCcKICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgICBvZmZzZXQgPSAwCiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpCiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgZW5jb2RpbmcgPSBvZmZzZXQKICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgICBvZmZzZXQgPSAwCiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSkKICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHsKICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwCiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JwogICAgfSBlbHNlIHsKICAgICAgZW5jb2RpbmcgPSBsZW5ndGgKICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkCiAgICB9CiAgfSBlbHNlIHsKICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJwogICAgKQogIH0KCiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0CiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nCgogIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKQogIH0KCiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCcKCiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKICBmb3IgKDs7KSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGUKICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CgpCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7CiAgcmV0dXJuIHsKICAgIHR5cGU6ICdCdWZmZXInLAogICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApCiAgfQp9CgpmdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewogICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZikKICB9IGVsc2UgewogICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSkKICB9Cn0KCmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKQogIHZhciByZXMgPSBbXQoKICB2YXIgaSA9IHN0YXJ0CiAgd2hpbGUgKGkgPCBlbmQpIHsKICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV0KICAgIHZhciBjb2RlUG9pbnQgPSBudWxsCiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDQKICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzCiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMgogICAgICA6IDEKCiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQKCiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewogICAgICAgIGNhc2UgMToKICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpCiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RikgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDM6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7CiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludAogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBicmVhawogICAgICAgIGNhc2UgNDoKICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdCiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdCiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpCiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkgewogICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhCiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGUKICAgICAgY29kZVBvaW50ID0gMHhGRkZECiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikgewogICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKQogICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMAogICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApCiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGCiAgICB9CgogICAgcmVzLnB1c2goY29kZVBvaW50KQogICAgaSArPSBieXRlc1BlclNlcXVlbmNlCiAgfQoKICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcykKfQoKLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoCi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy4KLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eQp2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDAKCmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykgewogIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aAogIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKQogIH0KCiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCAiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkIi4KICB2YXIgcmVzID0gJycKICB2YXIgaSA9IDAKICB3aGlsZSAoaSA8IGxlbikgewogICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoCiAgICAgIFN0cmluZywKICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKQogICAgKQogIH0KICByZXR1cm4gcmVzCn0KCmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciByZXQgPSAnJwogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpCiAgfQogIHJldHVybiByZXQKfQoKZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciByZXQgPSAnJwogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSkKICB9CiAgcmV0dXJuIHJldAp9CgpmdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGgKCiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMAogIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW4KCiAgdmFyIG91dCA9ICcnCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIG91dCArPSB0b0hleChidWZbaV0pCiAgfQogIHJldHVybiBvdXQKfQoKZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCkKICB2YXIgcmVzID0gJycKICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7CiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKQogIH0KICByZXR1cm4gcmVzCn0KCkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIHN0YXJ0ID0gfn5zdGFydAogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQKCiAgaWYgKHN0YXJ0IDwgMCkgewogICAgc3RhcnQgKz0gbGVuCiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDAKICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7CiAgICBzdGFydCA9IGxlbgogIH0KCiAgaWYgKGVuZCA8IDApIHsKICAgIGVuZCArPSBsZW4KICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwCiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgIGVuZCA9IGxlbgogIH0KCiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydAoKICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKQogIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlCiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGUKICByZXR1cm4gbmV3QnVmCn0KCi8qCiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLgogKi8KZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKQogIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJykKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XQogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsCiAgfQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCiAgfQoKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdCiAgdmFyIG11bCA9IDEKICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWwKICB9CgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKQogIHJldHVybiB0aGlzW29mZnNldF0KfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8CiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArCiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArCiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHwKICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHwKICAgIHRoaXNbb2Zmc2V0ICsgM10pCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKQoKICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdCiAgdmFyIG11bCA9IDEKICB2YXIgaSA9IDAKICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWwKICB9CiAgbXVsICo9IDB4ODAKCiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkKCiAgcmV0dXJuIHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIGkgPSBieXRlTGVuZ3RoCiAgdmFyIG11bCA9IDEKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldCiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsCiAgfQogIG11bCAqPSAweDgwCgogIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpCgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCkKICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pCiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpCiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KQogIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHwKICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHwKICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8CiAgICAodGhpc1tvZmZzZXQgKyAzXSkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpCn0KCmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJykKICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKQogIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCkKICB9CgogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCkKICB9CgogIHZhciBpID0gYnl0ZUxlbmd0aCAtIDEKICB2YXIgbXVsID0gMQogIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkYKICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KQogIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSkKCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCkKICB9CgogIHZhciBpID0gMAogIHZhciBtdWwgPSAxCiAgdmFyIHN1YiA9IDAKICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkYKICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHsKICAgICAgc3ViID0gMQogICAgfQogICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKQoKICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KQogIH0KCiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMQogIHZhciBtdWwgPSAxCiAgdmFyIHN1YiA9IDAKICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICBzdWIgPSAxCiAgICB9CiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGCiAgfQoKICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKQogIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDEKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZikKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KQogIHJldHVybiBvZmZzZXQgKyAyCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKQogIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpmdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCn0KCmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpCiAgfQogIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCn0KCmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpCiAgfQogIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KQogIHJldHVybiBvZmZzZXQgKyA4Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCn0KCi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aCkKQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpCiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwCiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aAogIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGgKICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDAKICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQKCiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lCiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwCiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwCgogIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnMKICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpCiAgfQogIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKQogIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKQoKICAvLyBBcmUgd2Ugb29iPwogIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGgKICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHsKICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0CiAgfQoKICB2YXIgbGVuID0gZW5kIC0gc3RhcnQKCiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykgewogICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMQogICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKQogIH0gZWxzZSBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHsKICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZAogICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7CiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdCiAgICB9CiAgfSBlbHNlIHsKICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKAogICAgICB0YXJnZXQsCiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksCiAgICAgIHRhcmdldFN0YXJ0CiAgICApCiAgfQoKICByZXR1cm4gbGVuCn0KCi8vIFVzYWdlOgovLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSkKLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pCi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKQpCdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7CiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczoKICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7CiAgICAgIGVuY29kaW5nID0gc3RhcnQKICAgICAgc3RhcnQgPSAwCiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoCiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7CiAgICAgIGVuY29kaW5nID0gZW5kCiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoCiAgICB9CiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKQogICAgfQogICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpCiAgICB9CiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkgewogICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApCiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fAogICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7CiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS4KICAgICAgICB2YWwgPSBjb2RlCiAgICAgIH0KICAgIH0KICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7CiAgICB2YWwgPSB2YWwgJiAyNTUKICB9CgogIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LgogIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpCiAgfQoKICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICByZXR1cm4gdGhpcwogIH0KCiAgc3RhcnQgPSBzdGFydCA+Pj4gMAogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDAKCiAgaWYgKCF2YWwpIHZhbCA9IDAKCiAgdmFyIGkKICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgdGhpc1tpXSA9IHZhbAogICAgfQogIH0gZWxzZSB7CiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKQogICAgICA/IHZhbAogICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykKICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGgKICAgIGlmIChsZW4gPT09IDApIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlICInICsgdmFsICsKICAgICAgICAnIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCAidmFsdWUiJykKICAgIH0KICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dCiAgICB9CiAgfQoKICByZXR1cm4gdGhpcwp9CgovLyBIRUxQRVIgRlVOQ1RJT05TCi8vID09PT09PT09PT09PT09PT0KCnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2cKCmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHsKICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nCiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF0KICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXG4gYW5kIFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90CiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJykKICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnCiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJycKICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3QKICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgIHN0ciA9IHN0ciArICc9JwogIH0KICByZXR1cm4gc3RyCn0KCmZ1bmN0aW9uIHRvSGV4IChuKSB7CiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpCiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpCn0KCmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7CiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eQogIHZhciBjb2RlUG9pbnQKICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aAogIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbAogIHZhciBieXRlcyA9IFtdCgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpCgogICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudAogICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHsKICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWQKICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgLy8gbm8gbGVhZCB5ZXQKICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7CiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsCiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7CiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkCiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQoKICAgICAgICAvLyB2YWxpZCBsZWFkCiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludAoKICAgICAgICBjb250aW51ZQogICAgICB9CgogICAgICAvLyAyIGxlYWRzIGluIGEgcm93CiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHsKICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50CiAgICAgICAgY29udGludWUKICAgICAgfQoKICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXIKICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMAogICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7CiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWQKICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICB9CgogICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGwKCiAgICAvLyBlbmNvZGUgdXRmOAogICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHsKICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkgewogICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWsKICAgICAgYnl0ZXMucHVzaCgKICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCwKICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MAogICAgICApCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHsKICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLAogICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwCiAgICAgICkKICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHsKICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLAogICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCwKICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsCiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKICAgICAgKQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKQogICAgfQogIH0KCiAgcmV0dXJuIGJ5dGVzCn0KCmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7CiAgdmFyIGJ5dGVBcnJheSA9IFtdCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLgogICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKQogIH0KICByZXR1cm4gYnl0ZUFycmF5Cn0KCmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7CiAgdmFyIGMsIGhpLCBsbwogIHZhciBieXRlQXJyYXkgPSBbXQogIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWsKCiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSkKICAgIGhpID0gYyA+PiA4CiAgICBsbyA9IGMgJSAyNTYKICAgIGJ5dGVBcnJheS5wdXNoKGxvKQogICAgYnl0ZUFycmF5LnB1c2goaGkpCiAgfQoKICByZXR1cm4gYnl0ZUFycmF5Cn0KCmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikgewogIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSkKfQoKZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVhawogICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldCiAgfQogIHJldHVybiBpCn0KCi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sKLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NgpmdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHsKICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwKICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJgogICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKQp9CgpmdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7CiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlCn0KCn0seyJiYXNlNjQtanMiOjI1LCJpZWVlNzU0IjoyOX1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKdmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGwKdmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBvYmplY3RLZXlzUG9seWZpbGwKdmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbAoKZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkgewogIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkgewogICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwogIH0KCiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDsKfQptb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjsKCi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueApFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyOwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkOwpFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7CgovLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmUKLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy4KdmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDsKCnZhciBoYXNEZWZpbmVQcm9wZXJ0eTsKdHJ5IHsKICB2YXIgbyA9IHt9OwogIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7CiAgaGFzRGVmaW5lUHJvcGVydHkgPSBvLnggPT09IDA7Cn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH0KaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgZ2V0OiBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7CiAgICB9LAogICAgc2V0OiBmdW5jdGlvbihhcmcpIHsKICAgICAgLy8gY2hlY2sgd2hldGhlciB0aGUgaW5wdXQgaXMgYSBwb3NpdGl2ZSBudW1iZXIgKHdob3NlIHZhbHVlIGlzIHplcm8gb3IKICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS4KICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpCiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImRlZmF1bHRNYXhMaXN0ZW5lcnMiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTsKICAgICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZzsKICAgIH0KICB9KTsKfSBlbHNlIHsKICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7Cn0KCi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93cwovLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC4KRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikgewogIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpCiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibiIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpOwogIHRoaXMuX21heExpc3RlbmVycyA9IG47CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHsKICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpCiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7CiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVyczsKfQoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7CiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7Cn07CgovLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50Ci8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2YKLy8gYXJndW1lbnRzIGFuZCBjYW4gYmUgZGVvcHRpbWl6ZWQgYmVjYXVzZSBvZiB0aGF0LiBUaGVzZSBmdW5jdGlvbnMgYWx3YXlzIGhhdmUKLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZQovLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuCmZ1bmN0aW9uIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHNlbGYpIHsKICBpZiAoaXNGbikKICAgIGhhbmRsZXIuY2FsbChzZWxmKTsKICBlbHNlIHsKICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQogICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTsKICB9Cn0KZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7CiAgaWYgKGlzRm4pCiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSk7CiAgZWxzZSB7CiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7CiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkKICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7CiAgfQp9CmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikgewogIGlmIChpc0ZuKQogICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpOwogIGVsc2UgewogICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoOwogICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpCiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpOwogIH0KfQpmdW5jdGlvbiBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMiwgYXJnMykgewogIGlmIChpc0ZuKQogICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpOwogIGVsc2UgewogICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoOwogICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpCiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpOwogIH0KfQoKZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykgewogIGlmIChpc0ZuKQogICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTsKICBlbHNlIHsKICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDsKICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKQogICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkoc2VsZiwgYXJncyk7CiAgfQp9CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHsKICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzOwogIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpOwoKICBldmVudHMgPSB0aGlzLl9ldmVudHM7CiAgaWYgKGV2ZW50cykKICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7CiAgZWxzZSBpZiAoIWRvRXJyb3IpCiAgICByZXR1cm4gZmFsc2U7CgogIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy4KICBpZiAoZG9FcnJvcikgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKQogICAgICBlciA9IGFyZ3VtZW50c1sxXTsKICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudAogICAgfSBlbHNlIHsKICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlcgogICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgImVycm9yIiBldmVudC4gKCcgKyBlciArICcpJyk7CiAgICAgIGVyci5jb250ZXh0ID0gZXI7CiAgICAgIHRocm93IGVycjsKICAgIH0KICAgIHJldHVybiBmYWxzZTsKICB9CgogIGhhbmRsZXIgPSBldmVudHNbdHlwZV07CgogIGlmICghaGFuZGxlcikKICAgIHJldHVybiBmYWxzZTsKCiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJzsKICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOwogIHN3aXRjaCAobGVuKSB7CiAgICAgIC8vIGZhc3QgY2FzZXMKICAgIGNhc2UgMToKICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAyOgogICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAzOgogICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTsKICAgICAgYnJlYWs7CiAgICBjYXNlIDQ6CiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTsKICAgICAgYnJlYWs7CiAgICAgIC8vIHNsb3dlcgogICAgZGVmYXVsdDoKICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsKICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKQogICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldOwogICAgICBlbWl0TWFueShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmdzKTsKICB9CgogIHJldHVybiB0cnVlOwp9OwoKZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHsKICB2YXIgbTsKICB2YXIgZXZlbnRzOwogIHZhciBleGlzdGluZzsKCiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0ZW5lciIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogIGlmICghZXZlbnRzKSB7CiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTsKICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwOwogIH0gZWxzZSB7CiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSAibmV3TGlzdGVuZXIiISBCZWZvcmUKICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0ICJuZXdMaXN0ZW5lciIuCiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7CiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsCiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpOwoKICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZQogICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0CiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzOwogICAgfQogICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07CiAgfQoKICBpZiAoIWV4aXN0aW5nKSB7CiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC4KICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7CiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7CiAgfSBlbHNlIHsKICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHsKICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuCiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0KICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdOwogICAgfSBlbHNlIHsKICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLgogICAgICBpZiAocHJlcGVuZCkgewogICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpOwogICAgICB9IGVsc2UgewogICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpOwogICAgICB9CiAgICB9CgogICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWsKICAgIGlmICghZXhpc3Rpbmcud2FybmVkKSB7CiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7CiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHsKICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlOwogICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgKwogICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICInICsgU3RyaW5nKHR5cGUpICsgJyIgbGlzdGVuZXJzICcgKwogICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKwogICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQuJyk7CiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7CiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0OwogICAgICAgIHcudHlwZSA9IHR5cGU7CiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDsKICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2FybikgewogICAgICAgICAgY29uc29sZS53YXJuKCclczogJXMnLCB3Lm5hbWUsIHcubWVzc2FnZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gdGFyZ2V0Owp9CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0KICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTsKICAgIH07CgpmdW5jdGlvbiBvbmNlV3JhcHBlcigpIHsKICBpZiAoIXRoaXMuZmlyZWQpIHsKICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pOwogICAgdGhpcy5maXJlZCA9IHRydWU7CiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHsKICAgICAgY2FzZSAwOgogICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpOwogICAgICBjYXNlIDE6CiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTsKICAgICAgY2FzZSAyOgogICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTsKICAgICAgY2FzZSAzOgogICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLAogICAgICAgICAgICBhcmd1bWVudHNbMl0pOwogICAgICBkZWZhdWx0OgogICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkKICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07CiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikgewogIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9OwogIHZhciB3cmFwcGVkID0gYmluZC5jYWxsKG9uY2VXcmFwcGVyLCBzdGF0ZSk7CiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyOwogIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7CiAgcmV0dXJuIHdyYXBwZWQ7Cn0KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHsKICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKQogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3RlbmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpOwogIHJldHVybiB0aGlzOwp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID0KICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdGVuZXIiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpOwogICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC4KRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9CiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjsKCiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpCiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3RlbmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKCiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50czsKICAgICAgaWYgKCFldmVudHMpCiAgICAgICAgcmV0dXJuIHRoaXM7CgogICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdOwogICAgICBpZiAoIWxpc3QpCiAgICAgICAgcmV0dXJuIHRoaXM7CgogICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHsKICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkKICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07CiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgcG9zaXRpb24gPSAtMTsKCiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7CiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyOwogICAgICAgICAgICBwb3NpdGlvbiA9IGk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkKICAgICAgICAgIHJldHVybiB0aGlzOwoKICAgICAgICBpZiAocG9zaXRpb24gPT09IDApCiAgICAgICAgICBsaXN0LnNoaWZ0KCk7CiAgICAgICAgZWxzZQogICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTsKCiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKQogICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTsKCiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcikKICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPQogICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHsKICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpOwoKICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwogICAgICBpZiAoIWV2ZW50cykKICAgICAgICByZXR1cm4gdGhpczsKCiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXQKICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHsKICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwOwogICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdKSB7CiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMCkKICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzCiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7CiAgICAgICAgdmFyIGtleTsKICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkgewogICAgICAgICAga2V5ID0ga2V5c1tpXTsKICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlOwogICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTsKICAgICAgICB9CiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7CiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpOwogICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQoKICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdOwoKICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7CiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7CiAgICAgICAgLy8gTElGTyBvcmRlcgogICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pOwogICAgICAgIH0KICAgICAgfQoKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9OwoKZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkgewogIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50czsKCiAgaWYgKCFldmVudHMpCiAgICByZXR1cm4gW107CgogIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdOwogIGlmICghZXZsaXN0ZW5lcikKICAgIHJldHVybiBbXTsKCiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKQogICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdOwoKICByZXR1cm4gdW53cmFwID8gdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7Cn0KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHsKICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTsKfTsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHsKICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7Cn07CgpFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHsKICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykgewogICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTsKICB9IGVsc2UgewogICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTsKICB9Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50OwpmdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHsKICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzOwoKICBpZiAoZXZlbnRzKSB7CiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTsKCiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHsKICAgICAgcmV0dXJuIDE7CiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHsKICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoOwogICAgfQogIH0KCiAgcmV0dXJuIDA7Cn0KCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7CiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107Cn07CgovLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuCmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkgewogIGZvciAodmFyIGkgPSBpbmRleCwgayA9IGkgKyAxLCBuID0gbGlzdC5sZW5ndGg7IGsgPCBuOyBpICs9IDEsIGsgKz0gMSkKICAgIGxpc3RbaV0gPSBsaXN0W2tdOwogIGxpc3QucG9wKCk7Cn0KCmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7CiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpCiAgICBjb3B5W2ldID0gYXJyW2ldOwogIHJldHVybiBjb3B5Owp9CgpmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7CiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsKICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkgewogICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTsKICB9CiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHsKICB2YXIgRiA9IGZ1bmN0aW9uKCkge307CiAgRi5wcm90b3R5cGUgPSBwcm90bzsKICByZXR1cm4gbmV3IEY7Cn0KZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikgewogIHZhciBrZXlzID0gW107CiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSkgewogICAga2V5cy5wdXNoKGspOwogIH0KICByZXR1cm4gazsKfQpmdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7CiAgdmFyIGZuID0gdGhpczsKICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7CiAgfTsKfQoKfSx7fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogIHZhciBlLCBtCiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMQogIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxCiAgdmFyIGVCaWFzID0gZU1heCA+PiAxCiAgdmFyIG5CaXRzID0gLTcKICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwCiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxCiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV0KCiAgaSArPSBkCgogIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpCiAgcyA+Pj0gKC1uQml0cykKICBuQml0cyArPSBlTGVuCiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKQogIGUgPj49ICgtbkJpdHMpCiAgbkJpdHMgKz0gbUxlbgogIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge30KCiAgaWYgKGUgPT09IDApIHsKICAgIGUgPSAxIC0gZUJpYXMKICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHsKICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KQogIH0gZWxzZSB7CiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pCiAgICBlID0gZSAtIGVCaWFzCiAgfQogIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pCn0KCmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICB2YXIgZSwgbSwgYwogIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDEKICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMQogIHZhciBlQmlhcyA9IGVNYXggPj4gMQogIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCkKICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpCiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xCiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDAKCiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSkKCiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHsKICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMAogICAgZSA9IGVNYXgKICB9IGVsc2UgewogICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpCiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgIGUtLQogICAgICBjICo9IDIKICAgIH0KICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICB2YWx1ZSArPSBydCAvIGMKICAgIH0gZWxzZSB7CiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKQogICAgfQogICAgaWYgKHZhbHVlICogYyA+PSAyKSB7CiAgICAgIGUrKwogICAgICBjIC89IDIKICAgIH0KCiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgbSA9IDAKICAgICAgZSA9IGVNYXgKICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbikKICAgICAgZSA9IGUgKyBlQmlhcwogICAgfSBlbHNlIHsKICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pCiAgICAgIGUgPSAwCiAgICB9CiAgfQoKICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fQoKICBlID0gKGUgPDwgbUxlbikgfCBtCiAgZUxlbiArPSBtTGVuCiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fQoKICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjgKfQoKfSx7fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewphcmd1bWVudHNbNF1bOF1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpCn0seyJkdXAiOjh9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7Ci8qIQogKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+CiAqIEBsaWNlbnNlICBNSVQKICovCgovLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nCi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7CiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcikKfQoKZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikgewogIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopCn0KCi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuCmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7CiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpCn0KCn0se31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyCnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTsKCi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdAovLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXMKLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYQovLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLgoKdmFyIGNhY2hlZFNldFRpbWVvdXQ7CnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7CgpmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkgewogICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7Cn0KZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpOwp9CihmdW5jdGlvbiAoKSB7CiAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDsKICAgICAgICB9CiAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7CiAgICB9CiAgICB0cnkgewogICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0OwogICAgICAgIH0KICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0OwogICAgfQp9ICgpKQpmdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikgewogICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHsKICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApOwogICAgfQogICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkgewogICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0OwogICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9CiAgICB0cnkgewogICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApOwogICAgfSBjYXRjaChlKXsKICAgICAgICB0cnkgewogICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHkKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApOwogICAgICAgIH0gY2F0Y2goZSl7CiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yCiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTsKICAgICAgICB9CiAgICB9CgoKfQpmdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7CiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHsKICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnMKICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9CiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkCiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHsKICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7CiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpOwogICAgfQogICAgdHJ5IHsKICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzCiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpOwogICAgfSBjYXRjaCAoZSl7CiAgICAgICAgdHJ5IHsKICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseQogICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTsKICAgICAgICB9IGNhdGNoIChlKXsKICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuCiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXQKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7CiAgICAgICAgfQogICAgfQoKCgp9CnZhciBxdWV1ZSA9IFtdOwp2YXIgZHJhaW5pbmcgPSBmYWxzZTsKdmFyIGN1cnJlbnRRdWV1ZTsKdmFyIHF1ZXVlSW5kZXggPSAtMTsKCmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHsKICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkgewogICAgICAgIHJldHVybjsKICAgIH0KICAgIGRyYWluaW5nID0gZmFsc2U7CiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkgewogICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7CiAgICB9IGVsc2UgewogICAgICAgIHF1ZXVlSW5kZXggPSAtMTsKICAgIH0KICAgIGlmIChxdWV1ZS5sZW5ndGgpIHsKICAgICAgICBkcmFpblF1ZXVlKCk7CiAgICB9Cn0KCmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7CiAgICBpZiAoZHJhaW5pbmcpIHsKICAgICAgICByZXR1cm47CiAgICB9CiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTsKICAgIGRyYWluaW5nID0gdHJ1ZTsKCiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoOwogICAgd2hpbGUobGVuKSB7CiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7CiAgICAgICAgcXVldWUgPSBbXTsKICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7CiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHsKICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBxdWV1ZUluZGV4ID0gLTE7CiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoOwogICAgfQogICAgY3VycmVudFF1ZXVlID0gbnVsbDsKICAgIGRyYWluaW5nID0gZmFsc2U7CiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7Cn0KCnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7CiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7CiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTsKICAgICAgICB9CiAgICB9CiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpOwogICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHsKICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpOwogICAgfQp9OwoKLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0cwpmdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHsKICAgIHRoaXMuZnVuID0gZnVuOwogICAgdGhpcy5hcnJheSA9IGFycmF5Owp9Ckl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpOwp9Owpwcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInOwpwcm9jZXNzLmJyb3dzZXIgPSB0cnVlOwpwcm9jZXNzLmVudiA9IHt9Owpwcm9jZXNzLmFyZ3YgPSBbXTsKcHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzCnByb2Nlc3MudmVyc2lvbnMgPSB7fTsKCmZ1bmN0aW9uIG5vb3AoKSB7fQoKcHJvY2Vzcy5vbiA9IG5vb3A7CnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLm9uY2UgPSBub29wOwpwcm9jZXNzLm9mZiA9IG5vb3A7CnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7CnByb2Nlc3MuZW1pdCA9IG5vb3A7CnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDsKcHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDsKCnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH0KCnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7Cn07Cgpwcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9Owpwcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikgewogICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTsKfTsKcHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTsKCn0se31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChzZXRJbW1lZGlhdGUsY2xlYXJJbW1lZGlhdGUpewp2YXIgbmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljazsKdmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5Owp2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7CnZhciBpbW1lZGlhdGVJZHMgPSB7fTsKdmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7CgovLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzcwoKZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7CiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpOwp9OwpleHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7CiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7Cn07CmV4cG9ydHMuY2xlYXJUaW1lb3V0ID0KZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkgeyB0aW1lb3V0LmNsb3NlKCk7IH07CgpmdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7CiAgdGhpcy5faWQgPSBpZDsKICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjsKfQpUaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307ClRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7CiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpOwp9OwoKLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuCmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHsKICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7CiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2VjczsKfTsKCmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7CiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpOwogIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7Cn07CgpleHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkgewogIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTsKCiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7CiAgaWYgKG1zZWNzID49IDApIHsKICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHsKICAgICAgaWYgKGl0ZW0uX29uVGltZW91dCkKICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTsKICAgIH0sIG1zZWNzKTsKICB9Cn07CgovLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS4KZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAiZnVuY3Rpb24iID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHsKICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKzsKICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZmFsc2UgOiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CgogIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlOwoKICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkgewogICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHsKICAgICAgLy8gZm4uY2FsbCgpIGlzIGZhc3RlciBzbyB3ZSBvcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiB1c2UtY2FzZQogICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndQogICAgICBpZiAoYXJncykgewogICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgICB9IGVsc2UgewogICAgICAgIGZuLmNhbGwobnVsbCk7CiAgICAgIH0KICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nCiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpOwogICAgfQogIH0pOwoKICByZXR1cm4gaWQ7Cn07CgpleHBvcnRzLmNsZWFySW1tZWRpYXRlID0gdHlwZW9mIGNsZWFySW1tZWRpYXRlID09PSAiZnVuY3Rpb24iID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkgewogIGRlbGV0ZSBpbW1lZGlhdGVJZHNbaWRdOwp9Owp9KS5jYWxsKHRoaXMscmVxdWlyZSgidGltZXJzIikuc2V0SW1tZWRpYXRlLHJlcXVpcmUoInRpbWVycyIpLmNsZWFySW1tZWRpYXRlKQp9LHsicHJvY2Vzcy9icm93c2VyLmpzIjozMiwidGltZXJzIjozM31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHsKICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnCiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbicKICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJwogICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7Cn0KfSx7fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7CmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikgewogIGlmICghaXNTdHJpbmcoZikpIHsKICAgIHZhciBvYmplY3RzID0gW107CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTsKICAgIH0KICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTsKICB9CgogIHZhciBpID0gMTsKICB2YXIgYXJncyA9IGFyZ3VtZW50czsKICB2YXIgbGVuID0gYXJncy5sZW5ndGg7CiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkgewogICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7CiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4OwogICAgc3dpdGNoICh4KSB7CiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pOwogICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTsKICAgICAgY2FzZSAnJWonOgogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTsKICAgICAgICB9IGNhdGNoIChfKSB7CiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nOwogICAgICAgIH0KICAgICAgZGVmYXVsdDoKICAgICAgICByZXR1cm4geDsKICAgIH0KICB9KTsKICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkgewogICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHsKICAgICAgc3RyICs9ICcgJyArIHg7CiAgICB9IGVsc2UgewogICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTsKICAgIH0KICB9CiAgcmV0dXJuIHN0cjsKfTsKCgovLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLgovLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LgovLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLgpleHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHsKICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLgogIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9OwogIH0KCiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkgewogICAgcmV0dXJuIGZuOwogIH0KCiAgdmFyIHdhcm5lZCA9IGZhbHNlOwogIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7CiAgICBpZiAoIXdhcm5lZCkgewogICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7CiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7CiAgICAgICAgY29uc29sZS50cmFjZShtc2cpOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTsKICAgICAgfQogICAgICB3YXJuZWQgPSB0cnVlOwogICAgfQogICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfQoKICByZXR1cm4gZGVwcmVjYXRlZDsKfTsKCgp2YXIgZGVidWdzID0ge307CnZhciBkZWJ1Z0Vudmlyb247CmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHsKICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSkKICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7CiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7CiAgaWYgKCFkZWJ1Z3Nbc2V0XSkgewogICAgaWYgKG5ldyBSZWdFeHAoJ1xcYicgKyBzZXQgKyAnXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHsKICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkOwogICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkgewogICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpOwogICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpOwogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9OwogICAgfQogIH0KICByZXR1cm4gZGVidWdzW3NldF07Cn07CgoKLyoqCiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXQKICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuCiAqCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuCiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuCiAqLwovKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovCmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7CiAgLy8gZGVmYXVsdCBvcHRpb25zCiAgdmFyIGN0eCA9IHsKICAgIHNlZW46IFtdLAogICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IKICB9OwogIC8vIGxlZ2FjeS4uLgogIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTsKICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdOwogIGlmIChpc0Jvb2xlYW4ob3B0cykpIHsKICAgIC8vIGxlZ2FjeS4uLgogICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzOwogIH0gZWxzZSBpZiAob3B0cykgewogICAgLy8gZ290IGFuICJvcHRpb25zIiBvYmplY3QKICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpOwogIH0KICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zCiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTsKICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjsKICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTsKICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7CiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjsKICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7Cn0KZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDsKCgovLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3MKaW5zcGVjdC5jb2xvcnMgPSB7CiAgJ2JvbGQnIDogWzEsIDIyXSwKICAnaXRhbGljJyA6IFszLCAyM10sCiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLAogICdpbnZlcnNlJyA6IFs3LCAyN10sCiAgJ3doaXRlJyA6IFszNywgMzldLAogICdncmV5JyA6IFs5MCwgMzldLAogICdibGFjaycgOiBbMzAsIDM5XSwKICAnYmx1ZScgOiBbMzQsIDM5XSwKICAnY3lhbicgOiBbMzYsIDM5XSwKICAnZ3JlZW4nIDogWzMyLCAzOV0sCiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sCiAgJ3JlZCcgOiBbMzEsIDM5XSwKICAneWVsbG93JyA6IFszMywgMzldCn07CgovLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGUKaW5zcGVjdC5zdHlsZXMgPSB7CiAgJ3NwZWNpYWwnOiAnY3lhbicsCiAgJ251bWJlcic6ICd5ZWxsb3cnLAogICdib29sZWFuJzogJ3llbGxvdycsCiAgJ3VuZGVmaW5lZCc6ICdncmV5JywKICAnbnVsbCc6ICdib2xkJywKICAnc3RyaW5nJzogJ2dyZWVuJywKICAnZGF0ZSc6ICdtYWdlbnRhJywKICAvLyAibmFtZSI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmcKICAncmVnZXhwJzogJ3JlZCcKfTsKCgpmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7CiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTsKCiAgaWYgKHN0eWxlKSB7CiAgICByZXR1cm4gJ1x1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICsKICAgICAgICAgICAnXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7CiAgfSBlbHNlIHsKICAgIHJldHVybiBzdHI7CiAgfQp9CgoKZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHsKICByZXR1cm4gc3RyOwp9CgoKZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHsKICB2YXIgaGFzaCA9IHt9OwoKICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7CiAgICBoYXNoW3ZhbF0gPSB0cnVlOwogIH0pOwoKICByZXR1cm4gaGFzaDsKfQoKCmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykgewogIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy4KICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXQKICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiYKICAgICAgdmFsdWUgJiYKICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJgogICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWwKICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmCiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLgogICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7CiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7CiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHsKICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7CiAgICB9CiAgICByZXR1cm4gcmV0OwogIH0KCiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMKICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpOwogIGlmIChwcmltaXRpdmUpIHsKICAgIHJldHVybiBwcmltaXRpdmU7CiAgfQoKICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuCiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7CiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7CgogIGlmIChjdHguc2hvd0hpZGRlbikgewogICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTsKICB9CgogIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGUKICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweAogIGlmIChpc0Vycm9yKHZhbHVlKQogICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHsKICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7CiAgfQoKICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuCiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7CiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHsKICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJzsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTsKICAgIH0KICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTsKICAgIH0KICAgIGlmIChpc0RhdGUodmFsdWUpKSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTsKICAgIH0KICAgIGlmIChpc0Vycm9yKHZhbHVlKSkgewogICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpOwogICAgfQogIH0KCiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTsKCiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheQogIGlmIChpc0FycmF5KHZhbHVlKSkgewogICAgYXJyYXkgPSB0cnVlOwogICAgYnJhY2VzID0gWydbJywgJ10nXTsKICB9CgogIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9ucwogIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkgewogICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJzsKICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nOwogIH0KCiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHMKICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7CiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTsKICB9CgogIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZQogIGlmIChpc0RhdGUodmFsdWUpKSB7CiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7CiAgfQoKICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yCiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7CiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpOwogIH0KCiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7CiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTsKICB9CgogIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7CiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9CgogIGN0eC5zZWVuLnB1c2godmFsdWUpOwoKICB2YXIgb3V0cHV0OwogIGlmIChhcnJheSkgewogICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7CiAgfSBlbHNlIHsKICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkgewogICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7CiAgICB9KTsKICB9CgogIGN0eC5zZWVuLnBvcCgpOwoKICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpOwp9CgoKZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHsKICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7CiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkgewogICAgdmFyIHNpbXBsZSA9ICdcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXiJ8IiQvZywgJycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csICJcXCciKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwiL2csICciJykgKyAnXCcnOwogICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpOwogIH0KICBpZiAoaXNOdW1iZXIodmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTsKICBpZiAoaXNCb29sZWFuKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpOwogIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyAib2JqZWN0Iiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuCiAgaWYgKGlzTnVsbCh2YWx1ZSkpCiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpOwp9CgoKZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHsKICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nOwp9CgoKZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykgewogIHZhciBvdXRwdXQgPSBbXTsKICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkgewogICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7CiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsCiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTsKICAgIH0gZWxzZSB7CiAgICAgIG91dHB1dC5wdXNoKCcnKTsKICAgIH0KICB9CiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgewogICAgaWYgKCFrZXkubWF0Y2goL15cZCskLykpIHsKICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywKICAgICAgICAgIGtleSwgdHJ1ZSkpOwogICAgfQogIH0pOwogIHJldHVybiBvdXRwdXQ7Cn0KCgpmdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7CiAgdmFyIG5hbWUsIHN0ciwgZGVzYzsKICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07CiAgaWYgKGRlc2MuZ2V0KSB7CiAgICBpZiAoZGVzYy5zZXQpIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7CiAgICB9IGVsc2UgewogICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpOwogICAgfQogIH0gZWxzZSB7CiAgICBpZiAoZGVzYy5zZXQpIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9CiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkgewogICAgbmFtZSA9ICdbJyArIGtleSArICddJzsKICB9CiAgaWYgKCFzdHIpIHsKICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkgewogICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHsKICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpOwogICAgICB9IGVsc2UgewogICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7CiAgICAgIH0KICAgICAgaWYgKHN0ci5pbmRleE9mKCdcbicpID4gLTEpIHsKICAgICAgICBpZiAoYXJyYXkpIHsKICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXG4nKS5tYXAoZnVuY3Rpb24obGluZSkgewogICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7CiAgICAgICAgICB9KS5qb2luKCdcbicpLnN1YnN0cigyKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3RyID0gJ1xuJyArIHN0ci5zcGxpdCgnXG4nKS5tYXAoZnVuY3Rpb24obGluZSkgewogICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lOwogICAgICAgICAgfSkuam9pbignXG4nKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9CiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7CiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXGQrJC8pKSB7CiAgICAgIHJldHVybiBzdHI7CiAgICB9CiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpOwogICAgaWYgKG5hbWUubWF0Y2goL14iKFthLXpBLVpfXVthLXpBLVpfMC05XSopIiQvKSkgewogICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTsKICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7CiAgICB9IGVsc2UgewogICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csICJcXCciKQogICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCIvZywgJyInKQogICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXiJ8IiQpL2csICInIik7CiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7CiAgICB9CiAgfQoKICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7Cn0KCgpmdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykgewogIHZhciBudW1MaW5lc0VzdCA9IDA7CiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7CiAgICBudW1MaW5lc0VzdCsrOwogICAgaWYgKGN1ci5pbmRleE9mKCdcbicpID49IDApIG51bUxpbmVzRXN0Kys7CiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cdTAwMWJcW1xkXGQ/bS9nLCAnJykubGVuZ3RoICsgMTsKICB9LCAwKTsKCiAgaWYgKGxlbmd0aCA+IDYwKSB7CiAgICByZXR1cm4gYnJhY2VzWzBdICsKICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXG4gJykgKwogICAgICAgICAgICcgJyArCiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcbiAgJykgKwogICAgICAgICAgICcgJyArCiAgICAgICAgICAgYnJhY2VzWzFdOwogIH0KCiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTsKfQoKCi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYAovLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC4KZnVuY3Rpb24gaXNBcnJheShhcikgewogIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTsKfQpleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5OwoKZnVuY3Rpb24gaXNCb29sZWFuKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7Cn0KZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47CgpmdW5jdGlvbiBpc051bGwoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbDsKfQpleHBvcnRzLmlzTnVsbCA9IGlzTnVsbDsKCmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT0gbnVsbDsKfQpleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7CgpmdW5jdGlvbiBpc051bWJlcihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7Cn0KZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyOwoKZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnOwp9CmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZzsKCmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJzsKfQpleHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7CgpmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09PSB2b2lkIDA7Cn0KZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNSZWdFeHAocmUpIHsKICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7Cn0KZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwOwoKZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDsKfQpleHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7CgpmdW5jdGlvbiBpc0RhdGUoZCkgewogIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nOwp9CmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlOwoKZnVuY3Rpb24gaXNFcnJvcihlKSB7CiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmCiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpOwp9CmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7CgpmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwp9CmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247CgpmdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbAogICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJzsKfQpleHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7CgpleHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7CgpmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7CiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTsKfQoKCmZ1bmN0aW9uIHBhZChuKSB7CiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7Cn0KCgp2YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsCiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107CgovLyAyNiBGZWIgMTY6MTk6MzQKZnVuY3Rpb24gdGltZXN0YW1wKCkgewogIHZhciBkID0gbmV3IERhdGUoKTsKICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSwKICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLAogICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTsKICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpOwp9CgoKLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcApleHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkgewogIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpOwp9OwoKCi8qKgogKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuCiAqCiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmUKICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkCiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlCiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhcwogKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS4KICoKICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZQogKiAgICAgcHJvdG90eXBlLgogKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS4KICovCmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpOwoKZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHsKICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0CiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47CgogIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTsKICB2YXIgaSA9IGtleXMubGVuZ3RoOwogIHdoaWxlIChpLS0pIHsKICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTsKICB9CiAgcmV0dXJuIG9yaWdpbjsKfTsKCmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkgewogIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsKfQoKfSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vc3VwcG9ydC9pc0J1ZmZlciI6MzQsIl9wcm9jZXNzIjozMiwiaW5oZXJpdHMiOjMwfV19LHt9LFsyXSk7Cg==","base64").toString()
const inpageSuffix = '//# sourceURL=' + extension.extension.getURL('inpage_bundle.js?v=1.6.2') + '\n'
const inpageBundle = inpageContent + inpageSuffix

// Eventually this streaming injection could be replaced with:
// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.exportFunction
//
// But for now that is only Firefox
// If we create a FireFox-only code path using that API,
// MetaMask will be much faster loading and performant on Firefox.

if (shouldInjectAmoveo3()) {
    setupInjection()
}

/**
 * Creates a script tag that injects inpage.js
 */
function setupInjection() {
    try {
        // inject in-page script
        var scriptTag = document.createElement('script')
        scriptTag.textContent = inpageBundle
        scriptTag.onload = function () {
            this.parentNode.removeChild(this)
        }
        var container = document.head || document.documentElement
        // append as first child
        container.insertBefore(scriptTag, container.children[0])
    } catch (e) {
        console.error('Amoveo injection failed.', e)
    }
}

/**
 * Determines if Web3 should be injected
 *
 * @returns {boolean} {@code true} if Web3 should be injected
 */
function shouldInjectAmoveo3() {
    return doctypeCheck() && suffixCheck()
        && documentElementCheck() && whitelistedDomainCheck();
}

/**
 * Checks the doctype of the current document if it exists
 *
 * @returns {boolean} {@code true} if the doctype is html or if none exists
 */
function doctypeCheck() {
    const doctype = window.document.doctype
    if (doctype) {
        return doctype.name === 'html'
    } else {
        return true
    }
}

/**
 * Checks the current document extension
 *
 * @returns {boolean} {@code true} if the current extension is not prohibited
 */
function suffixCheck() {
    var prohibitedTypes = ['xml', 'pdf']
    var currentUrl = window.location.href
    var currentRegex
    for (let i = 0; i < prohibitedTypes.length; i++) {
        currentRegex = new RegExp(`\\.${prohibitedTypes[i]}$`)
        if (currentRegex.test(currentUrl)) {
            return false
        }
    }
    return true
}

/**
 * Checks the documentElement of the current document
 *
 * @returns {boolean} {@code true} if the documentElement is an html node or if none exists
 */
function documentElementCheck() {
    var documentElement = document.documentElement.nodeName
    if (documentElement) {
        return documentElement.toLowerCase() === 'html'
    }
    return true
}

/**
 * Checks if the current domain is blacklisted
 *
 * @returns {boolean} {@code true} if the current domain is blacklisted
 */
function blacklistedDomainCheck() {
    var blacklistedDomains = [
        'uscourts.gov',
        'dropbox.com',
        'webbyawards.com',
        'cdn.shopify.com/s/javascripts/tricorder/xtld-read-only-frame.html',
    ]
    var currentUrl = window.location.href
    var currentRegex
    for (let i = 0; i < blacklistedDomains.length; i++) {
        const blacklistedDomain = blacklistedDomains[i].replace('.', '\\.')
        currentRegex = new RegExp(`(?:https?:\\/\\/)(?:(?!${blacklistedDomain}).)*$`)
        if (!currentRegex.test(currentUrl)) {
            return true
        }
    }
    return false
}

/**
 * Checks if the current domain is blacklisted
 *
 * @returns {boolean} {@code true} if the current domain is whitelisted
 */
function whitelistedDomainCheck() {
    var whitelistedDomains = [
        'localhost',
        'amoveobook.com',
    ]
    var currentUrl = window.location.href
    var currentRegex;
    var currentRegexHttp;
    for (let i = 0; i < whitelistedDomains.length; i++) {
        const whitelistedDomain = whitelistedDomains[i].replace('.', '\\.')
        currentRegex = new RegExp(`(?:https?:\\/\\/)(?:(?!${whitelistedDomain}).)*$`)
        if (!currentRegex.test(currentUrl)) {
            return true
        }
    }
    return false
}

}).call(this,require("buffer").Buffer)
},{"buffer":5,"extensionizer":3,"path":7}],2:[function(require,module,exports){
const apis = [
  'alarms',
  'bookmarks',
  'browserAction',
  'commands',
  'contextMenus',
  'cookies',
  'downloads',
  'events',
  'extension',
  'extensionTypes',
  'history',
  'i18n',
  'idle',
  'notifications',
  'pageAction',
  'runtime',
  'storage',
  'tabs',
  'webNavigation',
  'webRequest',
  'windows',
]

const hasChrome = typeof chrome !== 'undefined'
const hasWindow = typeof window !== 'undefined'
const hasBrowser = typeof browser !== 'undefined'

function Extension () {
  const _this = this

  apis.forEach(function (api) {

    _this[api] = null

    if (hasChrome) {
      try {
        if (chrome[api]) {
          _this[api] = chrome[api]
        }
      } catch (e) {
      }
    }

    if (hasWindow) {
      try {
        if (window[api]) {
          _this[api] = window[api]
        }
      } catch (e) {
      }
    }

    if (hasBrowser) {
      try {
        if (browser[api]) {
          _this[api] = browser[api]
        }
      } catch (e) {
      }
      try {
        _this.api = browser.extension[api]
      } catch (e) {
      }
    }
  })

  if (hasBrowser) {
    try {
      if (browser && browser.runtime) {
        this.runtime = browser.runtime
      }
    } catch (e) {
    }

    try {
      if (browser && browser.browserAction) {
        this.browserAction = browser.browserAction
      }
    } catch (e) {
    }
  }

}

module.exports = Extension

},{}],3:[function(require,module,exports){
/* Extension.js
 *
 * A module for unifying browser differences in the WebExtension API.
 *
 * Initially implemented because Chrome hides all of their WebExtension API
 * behind a global `chrome` variable, but we'd like to start grooming
 * the code-base for cross-browser extension support.
 *
 * You can read more about the WebExtension API here:
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions
 */

const Extension = require('./extension-instance')
module.exports = new Extension()

},{"./extension-instance":2}],4:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],5:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  get: function () {
    if (!(this instanceof Buffer)) {
      return undefined
    }
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (ArrayBuffer.isView(buf)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":4,"ieee754":6}],6:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],7:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":8}],8:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
